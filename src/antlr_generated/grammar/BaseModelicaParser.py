# Generated from ./grammar/BaseModelica.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,80,1059,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,1,0,1,0,1,0,1,0,3,0,167,8,0,1,0,1,0,1,0,1,
        0,3,0,173,8,0,1,0,1,0,1,0,5,0,178,8,0,10,0,12,0,181,9,0,1,0,3,0,
        184,8,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,192,8,0,1,0,1,0,1,0,1,0,1,1,
        1,1,1,2,1,2,1,2,1,3,1,3,3,3,205,8,3,1,3,1,3,1,3,3,3,210,8,3,1,3,
        3,3,213,8,3,1,3,3,3,216,8,3,1,3,3,3,219,8,3,1,4,1,4,1,4,3,4,224,
        8,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,3,6,235,8,6,1,6,1,6,3,6,
        239,8,6,1,6,1,6,1,6,3,6,244,8,6,1,6,3,6,247,8,6,1,6,3,6,250,8,6,
        1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,5,7,263,8,7,10,7,12,
        7,266,9,7,1,7,1,7,1,7,1,8,1,8,1,9,1,9,1,9,5,9,276,8,9,10,9,12,9,
        279,9,9,1,10,1,10,1,10,1,11,3,11,285,8,11,1,11,1,11,1,11,5,11,290,
        8,11,10,11,12,11,293,9,11,1,11,1,11,1,11,1,11,5,11,299,8,11,10,11,
        12,11,302,9,11,1,11,1,11,1,11,1,11,1,11,5,11,309,8,11,10,11,12,11,
        312,9,11,1,11,3,11,315,8,11,1,11,1,11,1,11,1,11,5,11,321,8,11,10,
        11,12,11,324,9,11,5,11,326,8,11,10,11,12,11,329,9,11,1,11,3,11,332,
        8,11,1,11,1,11,3,11,336,8,11,1,11,3,11,339,8,11,1,11,3,11,342,8,
        11,1,11,3,11,345,8,11,1,11,5,11,348,8,11,10,11,12,11,351,9,11,1,
        11,1,11,1,11,3,11,356,8,11,1,12,1,12,1,13,1,13,1,13,3,13,363,8,13,
        1,13,1,13,1,13,3,13,368,8,13,1,13,1,13,1,14,1,14,3,14,374,8,14,1,
        15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,3,16,384,8,16,1,16,1,16,1,
        17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,18,1,18,3,18,398,8,18,1,
        18,1,18,1,18,5,18,403,8,18,10,18,12,18,406,9,18,1,18,5,18,409,8,
        18,10,18,12,18,412,9,18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
        3,19,422,8,19,1,19,1,19,1,19,1,19,5,19,428,8,19,10,19,12,19,431,
        9,19,1,19,1,19,1,19,1,19,5,19,437,8,19,10,19,12,19,440,9,19,5,19,
        442,8,19,10,19,12,19,445,9,19,1,20,3,20,448,8,20,1,20,1,20,1,20,
        1,20,1,20,1,20,1,21,1,21,1,21,1,21,1,22,1,22,1,22,3,22,463,8,22,
        1,22,1,22,1,22,1,23,3,23,469,8,23,1,23,3,23,472,8,23,1,24,1,24,1,
        24,5,24,477,8,24,10,24,12,24,480,9,24,1,25,1,25,1,25,1,26,1,26,3,
        26,487,8,26,1,26,3,26,490,8,26,1,27,1,27,1,27,3,27,495,8,27,1,27,
        1,27,1,27,1,27,3,27,501,8,27,1,28,1,28,3,28,505,8,28,1,28,1,28,1,
        29,1,29,1,29,5,29,512,8,29,10,29,12,29,515,9,29,1,30,3,30,518,8,
        30,1,30,1,30,1,31,1,31,1,32,1,32,3,32,526,8,32,1,32,1,32,1,33,3,
        33,531,8,33,1,33,1,33,3,33,535,8,33,1,33,1,33,3,33,539,8,33,1,33,
        1,33,1,33,3,33,544,8,33,1,33,1,33,1,34,1,34,3,34,550,8,34,1,35,3,
        35,553,8,35,1,35,1,35,1,35,1,35,3,35,559,8,35,1,35,1,35,1,35,1,35,
        1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,574,8,35,1,35,
        1,35,1,36,1,36,1,36,1,36,1,36,1,36,5,36,584,8,36,10,36,12,36,587,
        9,36,1,36,1,36,1,36,1,36,1,36,1,36,5,36,595,8,36,10,36,12,36,598,
        9,36,5,36,600,8,36,10,36,12,36,603,9,36,1,36,1,36,1,36,1,36,5,36,
        609,8,36,10,36,12,36,612,9,36,3,36,614,8,36,1,36,1,36,1,36,1,37,
        1,37,1,37,1,37,1,37,1,37,5,37,625,8,37,10,37,12,37,628,9,37,1,37,
        1,37,1,37,1,37,1,37,1,37,5,37,636,8,37,10,37,12,37,639,9,37,5,37,
        641,8,37,10,37,12,37,644,9,37,1,37,1,37,1,37,1,37,5,37,650,8,37,
        10,37,12,37,653,9,37,3,37,655,8,37,1,37,1,37,1,37,1,38,1,38,1,38,
        1,38,1,38,1,38,5,38,666,8,38,10,38,12,38,669,9,38,1,38,1,38,1,38,
        1,39,1,39,1,39,1,39,1,39,1,39,5,39,680,8,39,10,39,12,39,683,9,39,
        1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,
        5,41,698,8,41,10,41,12,41,701,9,41,1,41,1,41,1,41,1,42,1,42,1,42,
        1,42,1,42,1,42,5,42,712,8,42,10,42,12,42,715,9,42,1,42,1,42,1,42,
        1,42,1,42,1,42,5,42,723,8,42,10,42,12,42,726,9,42,5,42,728,8,42,
        10,42,12,42,731,9,42,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,43,1,43,
        5,43,742,8,43,10,43,12,43,745,9,43,1,43,1,43,1,43,1,43,1,43,1,43,
        5,43,753,8,43,10,43,12,43,756,9,43,5,43,758,8,43,10,43,12,43,761,
        9,43,1,43,1,43,1,43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,45,1,45,
        1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,47,1,47,1,47,1,48,1,48,3,48,
        787,8,48,1,49,1,49,3,49,791,8,49,1,50,1,50,1,50,1,50,1,50,1,50,1,
        50,1,50,1,50,5,50,802,8,50,10,50,12,50,805,9,50,1,50,1,50,1,50,1,
        51,1,51,1,51,1,51,1,51,3,51,815,8,51,3,51,817,8,51,1,52,1,52,1,52,
        5,52,822,8,52,10,52,12,52,825,9,52,1,53,1,53,1,53,5,53,830,8,53,
        10,53,12,53,833,9,53,1,54,3,54,836,8,54,1,54,1,54,1,55,1,55,1,55,
        1,55,3,55,844,8,55,1,56,1,56,1,57,3,57,849,8,57,1,57,1,57,1,57,1,
        57,5,57,855,8,57,10,57,12,57,858,9,57,1,58,1,58,1,59,1,59,1,59,1,
        59,5,59,866,8,59,10,59,12,59,869,9,59,1,60,1,60,1,61,1,61,1,61,3,
        61,876,8,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,886,8,62,
        1,62,1,62,1,62,1,62,3,62,892,8,62,1,62,1,62,1,62,1,62,5,62,898,8,
        62,10,62,12,62,901,9,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,
        910,8,62,1,63,3,63,913,8,63,1,63,1,63,1,64,1,64,1,64,5,64,920,8,
        64,10,64,12,64,923,9,64,1,65,3,65,926,8,65,1,65,1,65,3,65,930,8,
        65,1,65,1,65,1,65,3,65,935,8,65,5,65,937,8,65,10,65,12,65,940,9,
        65,1,66,1,66,3,66,944,8,66,1,66,1,66,1,67,1,67,1,67,1,67,1,67,3,
        67,953,8,67,1,67,1,67,1,67,3,67,958,8,67,1,67,3,67,961,8,67,1,68,
        1,68,1,68,3,68,966,8,68,1,68,3,68,969,8,68,1,69,1,69,1,69,5,69,974,
        8,69,10,69,12,69,977,9,69,1,69,1,69,3,69,981,8,69,1,70,1,70,1,70,
        5,70,986,8,70,10,70,12,70,989,9,70,1,71,1,71,1,71,1,71,1,72,1,72,
        3,72,997,8,72,1,73,1,73,1,73,1,73,3,73,1003,8,73,1,73,1,73,1,74,
        3,74,1008,8,74,1,74,1,74,3,74,1012,8,74,5,74,1014,8,74,10,74,12,
        74,1017,9,74,1,75,1,75,1,75,5,75,1022,8,75,10,75,12,75,1025,9,75,
        1,76,1,76,1,76,1,76,5,76,1031,8,76,10,76,12,76,1034,9,76,1,76,1,
        76,1,77,1,77,3,77,1040,8,77,1,78,1,78,3,78,1044,8,78,1,79,1,79,1,
        79,5,79,1049,8,79,10,79,12,79,1052,9,79,3,79,1054,8,79,1,80,1,80,
        1,80,1,80,0,0,81,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,
        36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,
        80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
        118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,
        150,152,154,156,158,160,0,7,1,0,19,20,3,0,9,9,25,25,30,30,1,0,49,
        54,1,0,55,58,1,0,59,62,1,0,63,64,3,0,8,8,17,17,22,22,1129,0,162,
        1,0,0,0,2,197,1,0,0,0,4,199,1,0,0,0,6,218,1,0,0,0,8,223,1,0,0,0,
        10,225,1,0,0,0,12,231,1,0,0,0,14,253,1,0,0,0,16,270,1,0,0,0,18,272,
        1,0,0,0,20,280,1,0,0,0,22,291,1,0,0,0,24,357,1,0,0,0,26,362,1,0,
        0,0,28,373,1,0,0,0,30,375,1,0,0,0,32,377,1,0,0,0,34,387,1,0,0,0,
        36,392,1,0,0,0,38,413,1,0,0,0,40,447,1,0,0,0,42,455,1,0,0,0,44,459,
        1,0,0,0,46,468,1,0,0,0,48,473,1,0,0,0,50,481,1,0,0,0,52,484,1,0,
        0,0,54,500,1,0,0,0,56,502,1,0,0,0,58,508,1,0,0,0,60,517,1,0,0,0,
        62,521,1,0,0,0,64,523,1,0,0,0,66,530,1,0,0,0,68,549,1,0,0,0,70,552,
        1,0,0,0,72,577,1,0,0,0,74,618,1,0,0,0,76,659,1,0,0,0,78,673,1,0,
        0,0,80,687,1,0,0,0,82,691,1,0,0,0,84,705,1,0,0,0,86,735,1,0,0,0,
        88,765,1,0,0,0,90,772,1,0,0,0,92,779,1,0,0,0,94,781,1,0,0,0,96,784,
        1,0,0,0,98,790,1,0,0,0,100,792,1,0,0,0,102,809,1,0,0,0,104,818,1,
        0,0,0,106,826,1,0,0,0,108,835,1,0,0,0,110,839,1,0,0,0,112,845,1,
        0,0,0,114,848,1,0,0,0,116,859,1,0,0,0,118,861,1,0,0,0,120,870,1,
        0,0,0,122,872,1,0,0,0,124,909,1,0,0,0,126,912,1,0,0,0,128,916,1,
        0,0,0,130,925,1,0,0,0,132,941,1,0,0,0,134,960,1,0,0,0,136,968,1,
        0,0,0,138,970,1,0,0,0,140,982,1,0,0,0,142,990,1,0,0,0,144,996,1,
        0,0,0,146,998,1,0,0,0,148,1007,1,0,0,0,150,1018,1,0,0,0,152,1026,
        1,0,0,0,154,1039,1,0,0,0,156,1041,1,0,0,0,158,1053,1,0,0,0,160,1055,
        1,0,0,0,162,163,3,2,1,0,163,164,5,1,0,0,164,179,5,74,0,0,165,167,
        3,94,47,0,166,165,1,0,0,0,166,167,1,0,0,0,167,168,1,0,0,0,168,169,
        3,4,2,0,169,170,5,2,0,0,170,178,1,0,0,0,171,173,3,94,47,0,172,171,
        1,0,0,0,172,173,1,0,0,0,173,174,1,0,0,0,174,175,3,44,22,0,175,176,
        5,2,0,0,176,178,1,0,0,0,177,166,1,0,0,0,177,172,1,0,0,0,178,181,
        1,0,0,0,179,177,1,0,0,0,179,180,1,0,0,0,180,183,1,0,0,0,181,179,
        1,0,0,0,182,184,3,94,47,0,183,182,1,0,0,0,183,184,1,0,0,0,184,185,
        1,0,0,0,185,186,5,3,0,0,186,187,3,10,5,0,187,191,5,2,0,0,188,189,
        3,160,80,0,189,190,5,2,0,0,190,192,1,0,0,0,191,188,1,0,0,0,191,192,
        1,0,0,0,192,193,1,0,0,0,193,194,5,4,0,0,194,195,5,74,0,0,195,196,
        5,2,0,0,196,1,1,0,0,0,197,198,5,73,0,0,198,3,1,0,0,0,199,200,3,6,
        3,0,200,201,3,8,4,0,201,5,1,0,0,0,202,219,5,5,0,0,203,205,5,6,0,
        0,204,203,1,0,0,0,204,205,1,0,0,0,205,206,1,0,0,0,206,219,5,7,0,
        0,207,209,5,8,0,0,208,210,5,9,0,0,209,208,1,0,0,0,209,210,1,0,0,
        0,210,213,1,0,0,0,211,213,5,10,0,0,212,207,1,0,0,0,212,211,1,0,0,
        0,212,213,1,0,0,0,213,215,1,0,0,0,214,216,5,6,0,0,215,214,1,0,0,
        0,215,216,1,0,0,0,216,217,1,0,0,0,217,219,5,11,0,0,218,202,1,0,0,
        0,218,204,1,0,0,0,218,212,1,0,0,0,219,7,1,0,0,0,220,224,3,10,5,0,
        221,224,3,12,6,0,222,224,3,14,7,0,223,220,1,0,0,0,223,221,1,0,0,
        0,223,222,1,0,0,0,224,9,1,0,0,0,225,226,5,74,0,0,226,227,3,158,79,
        0,227,228,3,22,11,0,228,229,5,4,0,0,229,230,5,74,0,0,230,11,1,0,
        0,0,231,232,5,74,0,0,232,249,5,12,0,0,233,235,3,16,8,0,234,233,1,
        0,0,0,234,235,1,0,0,0,235,236,1,0,0,0,236,238,3,126,63,0,237,239,
        3,56,28,0,238,237,1,0,0,0,238,239,1,0,0,0,239,250,1,0,0,0,240,241,
        5,13,0,0,241,246,5,14,0,0,242,244,3,18,9,0,243,242,1,0,0,0,243,244,
        1,0,0,0,244,247,1,0,0,0,245,247,5,15,0,0,246,243,1,0,0,0,246,245,
        1,0,0,0,247,248,1,0,0,0,248,250,5,16,0,0,249,234,1,0,0,0,249,240,
        1,0,0,0,250,251,1,0,0,0,251,252,3,156,78,0,252,13,1,0,0,0,253,254,
        5,74,0,0,254,255,5,12,0,0,255,256,5,17,0,0,256,257,5,14,0,0,257,
        258,3,126,63,0,258,259,5,18,0,0,259,264,5,74,0,0,260,261,5,18,0,
        0,261,263,5,74,0,0,262,260,1,0,0,0,263,266,1,0,0,0,264,262,1,0,0,
        0,264,265,1,0,0,0,265,267,1,0,0,0,266,264,1,0,0,0,267,268,5,16,0,
        0,268,269,3,156,78,0,269,15,1,0,0,0,270,271,7,0,0,0,271,17,1,0,0,
        0,272,277,3,20,10,0,273,274,5,18,0,0,274,276,3,20,10,0,275,273,1,
        0,0,0,276,279,1,0,0,0,277,275,1,0,0,0,277,278,1,0,0,0,278,19,1,0,
        0,0,279,277,1,0,0,0,280,281,5,74,0,0,281,282,3,156,78,0,282,21,1,
        0,0,0,283,285,3,94,47,0,284,283,1,0,0,0,284,285,1,0,0,0,285,286,
        1,0,0,0,286,287,3,28,14,0,287,288,5,2,0,0,288,290,1,0,0,0,289,284,
        1,0,0,0,290,293,1,0,0,0,291,289,1,0,0,0,291,292,1,0,0,0,292,327,
        1,0,0,0,293,291,1,0,0,0,294,300,5,21,0,0,295,296,3,66,33,0,296,297,
        5,2,0,0,297,299,1,0,0,0,298,295,1,0,0,0,299,302,1,0,0,0,300,298,
        1,0,0,0,300,301,1,0,0,0,301,326,1,0,0,0,302,300,1,0,0,0,303,304,
        5,22,0,0,304,310,5,21,0,0,305,306,3,68,34,0,306,307,5,2,0,0,307,
        309,1,0,0,0,308,305,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,310,
        311,1,0,0,0,311,326,1,0,0,0,312,310,1,0,0,0,313,315,5,22,0,0,314,
        313,1,0,0,0,314,315,1,0,0,0,315,316,1,0,0,0,316,322,5,23,0,0,317,
        318,3,70,35,0,318,319,5,2,0,0,319,321,1,0,0,0,320,317,1,0,0,0,321,
        324,1,0,0,0,322,320,1,0,0,0,322,323,1,0,0,0,323,326,1,0,0,0,324,
        322,1,0,0,0,325,294,1,0,0,0,325,303,1,0,0,0,325,314,1,0,0,0,326,
        329,1,0,0,0,327,325,1,0,0,0,327,328,1,0,0,0,328,344,1,0,0,0,329,
        327,1,0,0,0,330,332,3,94,47,0,331,330,1,0,0,0,331,332,1,0,0,0,332,
        333,1,0,0,0,333,335,5,24,0,0,334,336,3,24,12,0,335,334,1,0,0,0,335,
        336,1,0,0,0,336,338,1,0,0,0,337,339,3,26,13,0,338,337,1,0,0,0,338,
        339,1,0,0,0,339,341,1,0,0,0,340,342,3,160,80,0,341,340,1,0,0,0,341,
        342,1,0,0,0,342,343,1,0,0,0,343,345,5,2,0,0,344,331,1,0,0,0,344,
        345,1,0,0,0,345,349,1,0,0,0,346,348,3,36,18,0,347,346,1,0,0,0,348,
        351,1,0,0,0,349,347,1,0,0,0,349,350,1,0,0,0,350,355,1,0,0,0,351,
        349,1,0,0,0,352,353,3,160,80,0,353,354,5,2,0,0,354,356,1,0,0,0,355,
        352,1,0,0,0,355,356,1,0,0,0,356,23,1,0,0,0,357,358,5,77,0,0,358,
        25,1,0,0,0,359,360,3,130,65,0,360,361,5,12,0,0,361,363,1,0,0,0,362,
        359,1,0,0,0,362,363,1,0,0,0,363,364,1,0,0,0,364,365,5,74,0,0,365,
        367,5,14,0,0,366,368,3,150,75,0,367,366,1,0,0,0,367,368,1,0,0,0,
        368,369,1,0,0,0,369,370,5,16,0,0,370,27,1,0,0,0,371,374,3,30,15,
        0,372,374,3,32,16,0,373,371,1,0,0,0,373,372,1,0,0,0,374,29,1,0,0,
        0,375,376,3,42,21,0,376,31,1,0,0,0,377,378,5,25,0,0,378,379,5,21,
        0,0,379,380,3,34,17,0,380,383,5,12,0,0,381,384,3,96,48,0,382,384,
        3,90,45,0,383,381,1,0,0,0,383,382,1,0,0,0,384,385,1,0,0,0,385,386,
        3,156,78,0,386,33,1,0,0,0,387,388,5,26,0,0,388,389,5,14,0,0,389,
        390,3,130,65,0,390,391,5,16,0,0,391,35,1,0,0,0,392,393,5,27,0,0,
        393,397,3,158,79,0,394,395,3,160,80,0,395,396,5,2,0,0,396,398,1,
        0,0,0,397,394,1,0,0,0,397,398,1,0,0,0,398,404,1,0,0,0,399,400,3,
        40,20,0,400,401,5,2,0,0,401,403,1,0,0,0,402,399,1,0,0,0,403,406,
        1,0,0,0,404,402,1,0,0,0,404,405,1,0,0,0,405,410,1,0,0,0,406,404,
        1,0,0,0,407,409,3,38,19,0,408,407,1,0,0,0,409,412,1,0,0,0,410,408,
        1,0,0,0,410,411,1,0,0,0,411,37,1,0,0,0,412,410,1,0,0,0,413,414,5,
        28,0,0,414,415,5,14,0,0,415,416,3,58,29,0,416,417,5,16,0,0,417,421,
        3,158,79,0,418,419,3,160,80,0,419,420,5,2,0,0,420,422,1,0,0,0,421,
        418,1,0,0,0,421,422,1,0,0,0,422,443,1,0,0,0,423,429,5,21,0,0,424,
        425,3,66,33,0,425,426,5,2,0,0,426,428,1,0,0,0,427,424,1,0,0,0,428,
        431,1,0,0,0,429,427,1,0,0,0,429,430,1,0,0,0,430,442,1,0,0,0,431,
        429,1,0,0,0,432,438,5,23,0,0,433,434,3,70,35,0,434,435,5,2,0,0,435,
        437,1,0,0,0,436,433,1,0,0,0,437,440,1,0,0,0,438,436,1,0,0,0,438,
        439,1,0,0,0,439,442,1,0,0,0,440,438,1,0,0,0,441,423,1,0,0,0,441,
        432,1,0,0,0,442,445,1,0,0,0,443,441,1,0,0,0,443,444,1,0,0,0,444,
        39,1,0,0,0,445,443,1,0,0,0,446,448,3,94,47,0,447,446,1,0,0,0,447,
        448,1,0,0,0,448,449,1,0,0,0,449,450,5,29,0,0,450,451,5,74,0,0,451,
        452,5,12,0,0,452,453,3,96,48,0,453,454,3,156,78,0,454,41,1,0,0,0,
        455,456,3,46,23,0,456,457,3,126,63,0,457,458,3,48,24,0,458,43,1,
        0,0,0,459,460,5,9,0,0,460,462,3,126,63,0,461,463,3,152,76,0,462,
        461,1,0,0,0,462,463,1,0,0,0,463,464,1,0,0,0,464,465,3,52,26,0,465,
        466,3,156,78,0,466,45,1,0,0,0,467,469,7,1,0,0,468,467,1,0,0,0,468,
        469,1,0,0,0,469,471,1,0,0,0,470,472,7,0,0,0,471,470,1,0,0,0,471,
        472,1,0,0,0,472,47,1,0,0,0,473,478,3,50,25,0,474,475,5,18,0,0,475,
        477,3,50,25,0,476,474,1,0,0,0,477,480,1,0,0,0,478,476,1,0,0,0,478,
        479,1,0,0,0,479,49,1,0,0,0,480,478,1,0,0,0,481,482,3,52,26,0,482,
        483,3,156,78,0,483,51,1,0,0,0,484,486,5,74,0,0,485,487,3,152,76,
        0,486,485,1,0,0,0,486,487,1,0,0,0,487,489,1,0,0,0,488,490,3,54,27,
        0,489,488,1,0,0,0,489,490,1,0,0,0,490,53,1,0,0,0,491,494,3,56,28,
        0,492,493,5,12,0,0,493,495,3,96,48,0,494,492,1,0,0,0,494,495,1,0,
        0,0,495,501,1,0,0,0,496,497,5,12,0,0,497,501,3,96,48,0,498,499,5,
        31,0,0,499,501,3,96,48,0,500,491,1,0,0,0,500,496,1,0,0,0,500,498,
        1,0,0,0,501,55,1,0,0,0,502,504,5,14,0,0,503,505,3,58,29,0,504,503,
        1,0,0,0,504,505,1,0,0,0,505,506,1,0,0,0,506,507,5,16,0,0,507,57,
        1,0,0,0,508,513,3,60,30,0,509,510,5,18,0,0,510,512,3,60,30,0,511,
        509,1,0,0,0,512,515,1,0,0,0,513,511,1,0,0,0,513,514,1,0,0,0,514,
        59,1,0,0,0,515,513,1,0,0,0,516,518,3,94,47,0,517,516,1,0,0,0,517,
        518,1,0,0,0,518,519,1,0,0,0,519,520,3,62,31,0,520,61,1,0,0,0,521,
        522,3,64,32,0,522,63,1,0,0,0,523,525,3,128,64,0,524,526,3,54,27,
        0,525,524,1,0,0,0,525,526,1,0,0,0,526,527,1,0,0,0,527,528,3,158,
        79,0,528,65,1,0,0,0,529,531,3,94,47,0,530,529,1,0,0,0,530,531,1,
        0,0,0,531,543,1,0,0,0,532,534,3,102,51,0,533,535,3,94,47,0,534,533,
        1,0,0,0,534,535,1,0,0,0,535,538,1,0,0,0,536,537,5,12,0,0,537,539,
        3,96,48,0,538,536,1,0,0,0,538,539,1,0,0,0,539,544,1,0,0,0,540,544,
        3,72,36,0,541,544,3,76,38,0,542,544,3,84,42,0,543,532,1,0,0,0,543,
        540,1,0,0,0,543,541,1,0,0,0,543,542,1,0,0,0,544,545,1,0,0,0,545,
        546,3,156,78,0,546,67,1,0,0,0,547,550,3,66,33,0,548,550,3,88,44,
        0,549,547,1,0,0,0,549,548,1,0,0,0,550,69,1,0,0,0,551,553,3,94,47,
        0,552,551,1,0,0,0,552,553,1,0,0,0,553,573,1,0,0,0,554,558,3,130,
        65,0,555,556,5,31,0,0,556,559,3,96,48,0,557,559,3,132,66,0,558,555,
        1,0,0,0,558,557,1,0,0,0,559,574,1,0,0,0,560,561,5,14,0,0,561,562,
        3,148,74,0,562,563,5,16,0,0,563,564,5,31,0,0,564,565,3,130,65,0,
        565,566,3,132,66,0,566,574,1,0,0,0,567,574,5,32,0,0,568,574,5,33,
        0,0,569,574,3,74,37,0,570,574,3,78,39,0,571,574,3,82,41,0,572,574,
        3,86,43,0,573,554,1,0,0,0,573,560,1,0,0,0,573,567,1,0,0,0,573,568,
        1,0,0,0,573,569,1,0,0,0,573,570,1,0,0,0,573,571,1,0,0,0,573,572,
        1,0,0,0,574,575,1,0,0,0,575,576,3,156,78,0,576,71,1,0,0,0,577,578,
        5,34,0,0,578,579,3,96,48,0,579,585,5,35,0,0,580,581,3,66,33,0,581,
        582,5,2,0,0,582,584,1,0,0,0,583,580,1,0,0,0,584,587,1,0,0,0,585,
        583,1,0,0,0,585,586,1,0,0,0,586,601,1,0,0,0,587,585,1,0,0,0,588,
        589,5,36,0,0,589,590,3,96,48,0,590,596,5,35,0,0,591,592,3,66,33,
        0,592,593,5,2,0,0,593,595,1,0,0,0,594,591,1,0,0,0,595,598,1,0,0,
        0,596,594,1,0,0,0,596,597,1,0,0,0,597,600,1,0,0,0,598,596,1,0,0,
        0,599,588,1,0,0,0,600,603,1,0,0,0,601,599,1,0,0,0,601,602,1,0,0,
        0,602,613,1,0,0,0,603,601,1,0,0,0,604,610,5,37,0,0,605,606,3,66,
        33,0,606,607,5,2,0,0,607,609,1,0,0,0,608,605,1,0,0,0,609,612,1,0,
        0,0,610,608,1,0,0,0,610,611,1,0,0,0,611,614,1,0,0,0,612,610,1,0,
        0,0,613,604,1,0,0,0,613,614,1,0,0,0,614,615,1,0,0,0,615,616,5,4,
        0,0,616,617,5,34,0,0,617,73,1,0,0,0,618,619,5,34,0,0,619,620,3,96,
        48,0,620,626,5,35,0,0,621,622,3,70,35,0,622,623,5,2,0,0,623,625,
        1,0,0,0,624,621,1,0,0,0,625,628,1,0,0,0,626,624,1,0,0,0,626,627,
        1,0,0,0,627,642,1,0,0,0,628,626,1,0,0,0,629,630,5,36,0,0,630,631,
        3,96,48,0,631,637,5,35,0,0,632,633,3,70,35,0,633,634,5,2,0,0,634,
        636,1,0,0,0,635,632,1,0,0,0,636,639,1,0,0,0,637,635,1,0,0,0,637,
        638,1,0,0,0,638,641,1,0,0,0,639,637,1,0,0,0,640,629,1,0,0,0,641,
        644,1,0,0,0,642,640,1,0,0,0,642,643,1,0,0,0,643,654,1,0,0,0,644,
        642,1,0,0,0,645,651,5,37,0,0,646,647,3,70,35,0,647,648,5,2,0,0,648,
        650,1,0,0,0,649,646,1,0,0,0,650,653,1,0,0,0,651,649,1,0,0,0,651,
        652,1,0,0,0,652,655,1,0,0,0,653,651,1,0,0,0,654,645,1,0,0,0,654,
        655,1,0,0,0,655,656,1,0,0,0,656,657,5,4,0,0,657,658,5,34,0,0,658,
        75,1,0,0,0,659,660,5,38,0,0,660,661,3,80,40,0,661,667,5,39,0,0,662,
        663,3,66,33,0,663,664,5,2,0,0,664,666,1,0,0,0,665,662,1,0,0,0,666,
        669,1,0,0,0,667,665,1,0,0,0,667,668,1,0,0,0,668,670,1,0,0,0,669,
        667,1,0,0,0,670,671,5,4,0,0,671,672,5,38,0,0,672,77,1,0,0,0,673,
        674,5,38,0,0,674,675,3,80,40,0,675,681,5,39,0,0,676,677,3,70,35,
        0,677,678,5,2,0,0,678,680,1,0,0,0,679,676,1,0,0,0,680,683,1,0,0,
        0,681,679,1,0,0,0,681,682,1,0,0,0,682,684,1,0,0,0,683,681,1,0,0,
        0,684,685,5,4,0,0,685,686,5,38,0,0,686,79,1,0,0,0,687,688,5,74,0,
        0,688,689,5,40,0,0,689,690,3,96,48,0,690,81,1,0,0,0,691,692,5,41,
        0,0,692,693,3,96,48,0,693,699,5,39,0,0,694,695,3,70,35,0,695,696,
        5,2,0,0,696,698,1,0,0,0,697,694,1,0,0,0,698,701,1,0,0,0,699,697,
        1,0,0,0,699,700,1,0,0,0,700,702,1,0,0,0,701,699,1,0,0,0,702,703,
        5,4,0,0,703,704,5,41,0,0,704,83,1,0,0,0,705,706,5,42,0,0,706,707,
        3,96,48,0,707,713,5,35,0,0,708,709,3,66,33,0,709,710,5,2,0,0,710,
        712,1,0,0,0,711,708,1,0,0,0,712,715,1,0,0,0,713,711,1,0,0,0,713,
        714,1,0,0,0,714,729,1,0,0,0,715,713,1,0,0,0,716,717,5,43,0,0,717,
        718,3,96,48,0,718,724,5,35,0,0,719,720,3,66,33,0,720,721,5,2,0,0,
        721,723,1,0,0,0,722,719,1,0,0,0,723,726,1,0,0,0,724,722,1,0,0,0,
        724,725,1,0,0,0,725,728,1,0,0,0,726,724,1,0,0,0,727,716,1,0,0,0,
        728,731,1,0,0,0,729,727,1,0,0,0,729,730,1,0,0,0,730,732,1,0,0,0,
        731,729,1,0,0,0,732,733,5,4,0,0,733,734,5,42,0,0,734,85,1,0,0,0,
        735,736,5,42,0,0,736,737,3,96,48,0,737,743,5,35,0,0,738,739,3,70,
        35,0,739,740,5,2,0,0,740,742,1,0,0,0,741,738,1,0,0,0,742,745,1,0,
        0,0,743,741,1,0,0,0,743,744,1,0,0,0,744,759,1,0,0,0,745,743,1,0,
        0,0,746,747,5,43,0,0,747,748,3,96,48,0,748,754,5,35,0,0,749,750,
        3,70,35,0,750,751,5,2,0,0,751,753,1,0,0,0,752,749,1,0,0,0,753,756,
        1,0,0,0,754,752,1,0,0,0,754,755,1,0,0,0,755,758,1,0,0,0,756,754,
        1,0,0,0,757,746,1,0,0,0,758,761,1,0,0,0,759,757,1,0,0,0,759,760,
        1,0,0,0,760,762,1,0,0,0,761,759,1,0,0,0,762,763,5,4,0,0,763,764,
        5,42,0,0,764,87,1,0,0,0,765,766,5,44,0,0,766,767,5,14,0,0,767,768,
        3,130,65,0,768,769,5,18,0,0,769,770,3,92,46,0,770,771,5,16,0,0,771,
        89,1,0,0,0,772,773,5,44,0,0,773,774,5,14,0,0,774,775,3,96,48,0,775,
        776,5,18,0,0,776,777,3,92,46,0,777,778,5,16,0,0,778,91,1,0,0,0,779,
        780,3,96,48,0,780,93,1,0,0,0,781,782,5,45,0,0,782,783,5,76,0,0,783,
        95,1,0,0,0,784,786,3,98,49,0,785,787,3,94,47,0,786,785,1,0,0,0,786,
        787,1,0,0,0,787,97,1,0,0,0,788,791,3,102,51,0,789,791,3,100,50,0,
        790,788,1,0,0,0,790,789,1,0,0,0,791,99,1,0,0,0,792,793,5,34,0,0,
        793,794,3,98,49,0,794,795,5,35,0,0,795,803,3,98,49,0,796,797,5,36,
        0,0,797,798,3,98,49,0,798,799,5,35,0,0,799,800,3,98,49,0,800,802,
        1,0,0,0,801,796,1,0,0,0,802,805,1,0,0,0,803,801,1,0,0,0,803,804,
        1,0,0,0,804,806,1,0,0,0,805,803,1,0,0,0,806,807,5,37,0,0,807,808,
        3,98,49,0,808,101,1,0,0,0,809,816,3,104,52,0,810,811,5,15,0,0,811,
        814,3,104,52,0,812,813,5,15,0,0,813,815,3,104,52,0,814,812,1,0,0,
        0,814,815,1,0,0,0,815,817,1,0,0,0,816,810,1,0,0,0,816,817,1,0,0,
        0,817,103,1,0,0,0,818,823,3,106,53,0,819,820,5,46,0,0,820,822,3,
        106,53,0,821,819,1,0,0,0,822,825,1,0,0,0,823,821,1,0,0,0,823,824,
        1,0,0,0,824,105,1,0,0,0,825,823,1,0,0,0,826,831,3,108,54,0,827,828,
        5,47,0,0,828,830,3,108,54,0,829,827,1,0,0,0,830,833,1,0,0,0,831,
        829,1,0,0,0,831,832,1,0,0,0,832,107,1,0,0,0,833,831,1,0,0,0,834,
        836,5,48,0,0,835,834,1,0,0,0,835,836,1,0,0,0,836,837,1,0,0,0,837,
        838,3,110,55,0,838,109,1,0,0,0,839,843,3,114,57,0,840,841,3,112,
        56,0,841,842,3,114,57,0,842,844,1,0,0,0,843,840,1,0,0,0,843,844,
        1,0,0,0,844,111,1,0,0,0,845,846,7,2,0,0,846,113,1,0,0,0,847,849,
        3,116,58,0,848,847,1,0,0,0,848,849,1,0,0,0,849,850,1,0,0,0,850,856,
        3,118,59,0,851,852,3,116,58,0,852,853,3,118,59,0,853,855,1,0,0,0,
        854,851,1,0,0,0,855,858,1,0,0,0,856,854,1,0,0,0,856,857,1,0,0,0,
        857,115,1,0,0,0,858,856,1,0,0,0,859,860,7,3,0,0,860,117,1,0,0,0,
        861,867,3,122,61,0,862,863,3,120,60,0,863,864,3,122,61,0,864,866,
        1,0,0,0,865,862,1,0,0,0,866,869,1,0,0,0,867,865,1,0,0,0,867,868,
        1,0,0,0,868,119,1,0,0,0,869,867,1,0,0,0,870,871,7,4,0,0,871,121,
        1,0,0,0,872,875,3,124,62,0,873,874,7,5,0,0,874,876,3,124,62,0,875,
        873,1,0,0,0,875,876,1,0,0,0,876,123,1,0,0,0,877,910,5,75,0,0,878,
        910,5,77,0,0,879,910,5,65,0,0,880,910,5,66,0,0,881,882,7,6,0,0,882,
        910,3,132,66,0,883,885,3,130,65,0,884,886,3,132,66,0,885,884,1,0,
        0,0,885,886,1,0,0,0,886,910,1,0,0,0,887,888,5,14,0,0,888,889,3,148,
        74,0,889,891,5,16,0,0,890,892,3,152,76,0,891,890,1,0,0,0,891,892,
        1,0,0,0,892,910,1,0,0,0,893,894,5,67,0,0,894,899,3,150,75,0,895,
        896,5,2,0,0,896,898,3,150,75,0,897,895,1,0,0,0,898,901,1,0,0,0,899,
        897,1,0,0,0,899,900,1,0,0,0,900,902,1,0,0,0,901,899,1,0,0,0,902,
        903,5,68,0,0,903,910,1,0,0,0,904,905,5,69,0,0,905,906,3,138,69,0,
        906,907,5,70,0,0,907,910,1,0,0,0,908,910,5,4,0,0,909,877,1,0,0,0,
        909,878,1,0,0,0,909,879,1,0,0,0,909,880,1,0,0,0,909,881,1,0,0,0,
        909,883,1,0,0,0,909,887,1,0,0,0,909,893,1,0,0,0,909,904,1,0,0,0,
        909,908,1,0,0,0,910,125,1,0,0,0,911,913,5,71,0,0,912,911,1,0,0,0,
        912,913,1,0,0,0,913,914,1,0,0,0,914,915,3,128,64,0,915,127,1,0,0,
        0,916,921,5,74,0,0,917,918,5,71,0,0,918,920,5,74,0,0,919,917,1,0,
        0,0,920,923,1,0,0,0,921,919,1,0,0,0,921,922,1,0,0,0,922,129,1,0,
        0,0,923,921,1,0,0,0,924,926,5,71,0,0,925,924,1,0,0,0,925,926,1,0,
        0,0,926,927,1,0,0,0,927,929,5,74,0,0,928,930,3,152,76,0,929,928,
        1,0,0,0,929,930,1,0,0,0,930,938,1,0,0,0,931,932,5,71,0,0,932,934,
        5,74,0,0,933,935,3,152,76,0,934,933,1,0,0,0,934,935,1,0,0,0,935,
        937,1,0,0,0,936,931,1,0,0,0,937,940,1,0,0,0,938,936,1,0,0,0,938,
        939,1,0,0,0,939,131,1,0,0,0,940,938,1,0,0,0,941,943,5,14,0,0,942,
        944,3,134,67,0,943,942,1,0,0,0,943,944,1,0,0,0,944,945,1,0,0,0,945,
        946,5,16,0,0,946,133,1,0,0,0,947,952,3,96,48,0,948,949,5,18,0,0,
        949,953,3,136,68,0,950,951,5,38,0,0,951,953,3,80,40,0,952,948,1,
        0,0,0,952,950,1,0,0,0,952,953,1,0,0,0,953,961,1,0,0,0,954,957,3,
        146,73,0,955,956,5,18,0,0,956,958,3,136,68,0,957,955,1,0,0,0,957,
        958,1,0,0,0,958,961,1,0,0,0,959,961,3,140,70,0,960,947,1,0,0,0,960,
        954,1,0,0,0,960,959,1,0,0,0,961,135,1,0,0,0,962,965,3,144,72,0,963,
        964,5,18,0,0,964,966,3,136,68,0,965,963,1,0,0,0,965,966,1,0,0,0,
        966,969,1,0,0,0,967,969,3,140,70,0,968,962,1,0,0,0,968,967,1,0,0,
        0,969,137,1,0,0,0,970,980,3,96,48,0,971,972,5,18,0,0,972,974,3,96,
        48,0,973,971,1,0,0,0,974,977,1,0,0,0,975,973,1,0,0,0,975,976,1,0,
        0,0,976,981,1,0,0,0,977,975,1,0,0,0,978,979,5,38,0,0,979,981,3,80,
        40,0,980,975,1,0,0,0,980,978,1,0,0,0,981,139,1,0,0,0,982,987,3,142,
        71,0,983,984,5,18,0,0,984,986,3,142,71,0,985,983,1,0,0,0,986,989,
        1,0,0,0,987,985,1,0,0,0,987,988,1,0,0,0,988,141,1,0,0,0,989,987,
        1,0,0,0,990,991,5,74,0,0,991,992,5,12,0,0,992,993,3,144,72,0,993,
        143,1,0,0,0,994,997,3,146,73,0,995,997,3,96,48,0,996,994,1,0,0,0,
        996,995,1,0,0,0,997,145,1,0,0,0,998,999,5,11,0,0,999,1000,3,126,
        63,0,1000,1002,5,14,0,0,1001,1003,3,140,70,0,1002,1001,1,0,0,0,1002,
        1003,1,0,0,0,1003,1004,1,0,0,0,1004,1005,5,16,0,0,1005,147,1,0,0,
        0,1006,1008,3,96,48,0,1007,1006,1,0,0,0,1007,1008,1,0,0,0,1008,1015,
        1,0,0,0,1009,1011,5,18,0,0,1010,1012,3,96,48,0,1011,1010,1,0,0,0,
        1011,1012,1,0,0,0,1012,1014,1,0,0,0,1013,1009,1,0,0,0,1014,1017,
        1,0,0,0,1015,1013,1,0,0,0,1015,1016,1,0,0,0,1016,149,1,0,0,0,1017,
        1015,1,0,0,0,1018,1023,3,96,48,0,1019,1020,5,18,0,0,1020,1022,3,
        96,48,0,1021,1019,1,0,0,0,1022,1025,1,0,0,0,1023,1021,1,0,0,0,1023,
        1024,1,0,0,0,1024,151,1,0,0,0,1025,1023,1,0,0,0,1026,1027,5,67,0,
        0,1027,1032,3,154,77,0,1028,1029,5,18,0,0,1029,1031,3,154,77,0,1030,
        1028,1,0,0,0,1031,1034,1,0,0,0,1032,1030,1,0,0,0,1032,1033,1,0,0,
        0,1033,1035,1,0,0,0,1034,1032,1,0,0,0,1035,1036,5,68,0,0,1036,153,
        1,0,0,0,1037,1040,5,15,0,0,1038,1040,3,96,48,0,1039,1037,1,0,0,0,
        1039,1038,1,0,0,0,1040,155,1,0,0,0,1041,1043,3,158,79,0,1042,1044,
        3,160,80,0,1043,1042,1,0,0,0,1043,1044,1,0,0,0,1044,157,1,0,0,0,
        1045,1050,5,77,0,0,1046,1047,5,55,0,0,1047,1049,5,77,0,0,1048,1046,
        1,0,0,0,1049,1052,1,0,0,0,1050,1048,1,0,0,0,1050,1051,1,0,0,0,1051,
        1054,1,0,0,0,1052,1050,1,0,0,0,1053,1045,1,0,0,0,1053,1054,1,0,0,
        0,1054,159,1,0,0,0,1055,1056,5,72,0,0,1056,1057,3,56,28,0,1057,161,
        1,0,0,0,129,166,172,177,179,183,191,204,209,212,215,218,223,234,
        238,243,246,249,264,277,284,291,300,310,314,322,325,327,331,335,
        338,341,344,349,355,362,367,373,383,397,404,410,421,429,438,441,
        443,447,462,468,471,478,486,489,494,500,504,513,517,525,530,534,
        538,543,549,552,558,573,585,596,601,610,613,626,637,642,651,654,
        667,681,699,713,724,729,743,754,759,786,790,803,814,816,823,831,
        835,843,848,856,867,875,885,891,899,909,912,921,925,929,934,938,
        943,952,957,960,965,968,975,980,987,996,1002,1007,1011,1015,1023,
        1032,1039,1043,1050,1053
    ]

class BaseModelicaParser ( Parser ):

    grammarFileName = "BaseModelica.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'package'", "';'", "'model'", "'end'", 
                     "'type'", "'operator'", "'record'", "'pure'", "'constant'", 
                     "'impure'", "'function'", "'='", "'enumeration'", "'('", 
                     "':'", "')'", "'der'", "','", "'input'", "'output'", 
                     "'equation'", "'initial'", "'algorithm'", "'external'", 
                     "'parameter'", "'guess'", "'partition'", "'subpartition'", 
                     "'Clock'", "'discrete'", "':='", "'break'", "'return'", 
                     "'if'", "'then'", "'elseif'", "'else'", "'for'", "'loop'", 
                     "'in'", "'while'", "'when'", "'elsewhen'", "'prioritize'", 
                     "'@'", "'or'", "'and'", "'not'", "'<'", "'<='", "'>'", 
                     "'>='", "'=='", "'<>'", "'+'", "'-'", "'.+'", "'.-'", 
                     "'*'", "'/'", "'.*'", "'./'", "'^'", "'.^'", "'false'", 
                     "'true'", "'['", "']'", "'{'", "'}'", "'.'", "'annotation'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "VERSION_HEADER", "IDENT", "UNSIGNED_NUMBER", 
                      "UNSIGNED_INTEGER", "STRING", "WS", "LINE_COMMENT", 
                      "ML_COMMENT" ]

    RULE_baseModelica = 0
    RULE_versionHeader = 1
    RULE_classDefinition = 2
    RULE_classPrefixes = 3
    RULE_classSpecifier = 4
    RULE_longClassSpecifier = 5
    RULE_shortClassSpecifier = 6
    RULE_derClassSpecifier = 7
    RULE_basePrefix = 8
    RULE_enumList = 9
    RULE_enumerationLiteral = 10
    RULE_composition = 11
    RULE_languageSpecification = 12
    RULE_externalFunctionCall = 13
    RULE_genericElement = 14
    RULE_normalElement = 15
    RULE_parameterEquation = 16
    RULE_guessValue = 17
    RULE_basePartition = 18
    RULE_subPartition = 19
    RULE_clockClause = 20
    RULE_componentClause = 21
    RULE_globalConstant = 22
    RULE_typePrefix = 23
    RULE_componentList = 24
    RULE_componentDeclaration = 25
    RULE_declaration = 26
    RULE_modification = 27
    RULE_classModification = 28
    RULE_argumentList = 29
    RULE_argument = 30
    RULE_elementModificationOrReplaceable = 31
    RULE_elementModification = 32
    RULE_equation = 33
    RULE_initialEquation = 34
    RULE_statement = 35
    RULE_ifEquation = 36
    RULE_ifStatement = 37
    RULE_forEquation = 38
    RULE_forStatement = 39
    RULE_forIndex = 40
    RULE_whileStatement = 41
    RULE_whenEquation = 42
    RULE_whenStatement = 43
    RULE_prioritizeEquation = 44
    RULE_prioritizeExpression = 45
    RULE_priority = 46
    RULE_decoration = 47
    RULE_expression = 48
    RULE_expressionNoDecoration = 49
    RULE_ifExpression = 50
    RULE_simpleExpression = 51
    RULE_logicalExpression = 52
    RULE_logicalTerm = 53
    RULE_logicalFactor = 54
    RULE_relation = 55
    RULE_relationalOperator = 56
    RULE_arithmeticExpression = 57
    RULE_addOperator = 58
    RULE_term = 59
    RULE_mulOperator = 60
    RULE_factor = 61
    RULE_primary = 62
    RULE_typeSpecifier = 63
    RULE_name = 64
    RULE_componentReference = 65
    RULE_functionCallArgs = 66
    RULE_functionArguments = 67
    RULE_functionArgumentsNonFirst = 68
    RULE_arrayArguments = 69
    RULE_namedArguments = 70
    RULE_namedArgument = 71
    RULE_functionArgument = 72
    RULE_functionPartialApplication = 73
    RULE_outputExpressionList = 74
    RULE_expressionList = 75
    RULE_arraySubscripts = 76
    RULE_subscript = 77
    RULE_comment = 78
    RULE_stringComment = 79
    RULE_annotationComment = 80

    ruleNames =  [ "baseModelica", "versionHeader", "classDefinition", "classPrefixes", 
                   "classSpecifier", "longClassSpecifier", "shortClassSpecifier", 
                   "derClassSpecifier", "basePrefix", "enumList", "enumerationLiteral", 
                   "composition", "languageSpecification", "externalFunctionCall", 
                   "genericElement", "normalElement", "parameterEquation", 
                   "guessValue", "basePartition", "subPartition", "clockClause", 
                   "componentClause", "globalConstant", "typePrefix", "componentList", 
                   "componentDeclaration", "declaration", "modification", 
                   "classModification", "argumentList", "argument", "elementModificationOrReplaceable", 
                   "elementModification", "equation", "initialEquation", 
                   "statement", "ifEquation", "ifStatement", "forEquation", 
                   "forStatement", "forIndex", "whileStatement", "whenEquation", 
                   "whenStatement", "prioritizeEquation", "prioritizeExpression", 
                   "priority", "decoration", "expression", "expressionNoDecoration", 
                   "ifExpression", "simpleExpression", "logicalExpression", 
                   "logicalTerm", "logicalFactor", "relation", "relationalOperator", 
                   "arithmeticExpression", "addOperator", "term", "mulOperator", 
                   "factor", "primary", "typeSpecifier", "name", "componentReference", 
                   "functionCallArgs", "functionArguments", "functionArgumentsNonFirst", 
                   "arrayArguments", "namedArguments", "namedArgument", 
                   "functionArgument", "functionPartialApplication", "outputExpressionList", 
                   "expressionList", "arraySubscripts", "subscript", "comment", 
                   "stringComment", "annotationComment" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    VERSION_HEADER=73
    IDENT=74
    UNSIGNED_NUMBER=75
    UNSIGNED_INTEGER=76
    STRING=77
    WS=78
    LINE_COMMENT=79
    ML_COMMENT=80

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class BaseModelicaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def versionHeader(self):
            return self.getTypedRuleContext(BaseModelicaParser.VersionHeaderContext,0)


        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(BaseModelicaParser.IDENT)
            else:
                return self.getToken(BaseModelicaParser.IDENT, i)

        def longClassSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.LongClassSpecifierContext,0)


        def classDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ClassDefinitionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ClassDefinitionContext,i)


        def globalConstant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.GlobalConstantContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.GlobalConstantContext,i)


        def decoration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.DecorationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,i)


        def annotationComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.AnnotationCommentContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_baseModelica

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBaseModelica" ):
                listener.enterBaseModelica(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBaseModelica" ):
                listener.exitBaseModelica(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBaseModelica" ):
                return visitor.visitBaseModelica(self)
            else:
                return visitor.visitChildren(self)




    def baseModelica(self):

        localctx = BaseModelicaParser.BaseModelicaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_baseModelica)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.versionHeader()
            self.state = 163
            self.match(BaseModelicaParser.T__0)
            self.state = 164
            self.match(BaseModelicaParser.IDENT)
            self.state = 179
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 177
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                    if la_ == 1:
                        self.state = 166
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==45:
                            self.state = 165
                            self.decoration()


                        self.state = 168
                        self.classDefinition()
                        self.state = 169
                        self.match(BaseModelicaParser.T__1)
                        pass

                    elif la_ == 2:
                        self.state = 172
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==45:
                            self.state = 171
                            self.decoration()


                        self.state = 174
                        self.globalConstant()
                        self.state = 175
                        self.match(BaseModelicaParser.T__1)
                        pass

             
                self.state = 181
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 182
                self.decoration()


            self.state = 185
            self.match(BaseModelicaParser.T__2)
            self.state = 186
            self.longClassSpecifier()
            self.state = 187
            self.match(BaseModelicaParser.T__1)
            self.state = 191
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72:
                self.state = 188
                self.annotationComment()
                self.state = 189
                self.match(BaseModelicaParser.T__1)


            self.state = 193
            self.match(BaseModelicaParser.T__3)
            self.state = 194
            self.match(BaseModelicaParser.IDENT)
            self.state = 195
            self.match(BaseModelicaParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersionHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERSION_HEADER(self):
            return self.getToken(BaseModelicaParser.VERSION_HEADER, 0)

        def getRuleIndex(self):
            return BaseModelicaParser.RULE_versionHeader

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersionHeader" ):
                listener.enterVersionHeader(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersionHeader" ):
                listener.exitVersionHeader(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersionHeader" ):
                return visitor.visitVersionHeader(self)
            else:
                return visitor.visitChildren(self)




    def versionHeader(self):

        localctx = BaseModelicaParser.VersionHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_versionHeader)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(BaseModelicaParser.VERSION_HEADER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classPrefixes(self):
            return self.getTypedRuleContext(BaseModelicaParser.ClassPrefixesContext,0)


        def classSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.ClassSpecifierContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_classDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDefinition" ):
                listener.enterClassDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDefinition" ):
                listener.exitClassDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassDefinition" ):
                return visitor.visitClassDefinition(self)
            else:
                return visitor.visitChildren(self)




    def classDefinition(self):

        localctx = BaseModelicaParser.ClassDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_classDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.classPrefixes()
            self.state = 200
            self.classSpecifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassPrefixesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_classPrefixes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassPrefixes" ):
                listener.enterClassPrefixes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassPrefixes" ):
                listener.exitClassPrefixes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassPrefixes" ):
                return visitor.visitClassPrefixes(self)
            else:
                return visitor.visitChildren(self)




    def classPrefixes(self):

        localctx = BaseModelicaParser.ClassPrefixesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_classPrefixes)
        self._la = 0 # Token type
        try:
            self.state = 218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 202
                self.match(BaseModelicaParser.T__4)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 203
                    self.match(BaseModelicaParser.T__5)


                self.state = 206
                self.match(BaseModelicaParser.T__6)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 212
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [8]:
                    self.state = 207
                    self.match(BaseModelicaParser.T__7)
                    self.state = 209
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==9:
                        self.state = 208
                        self.match(BaseModelicaParser.T__8)


                    pass
                elif token in [10]:
                    self.state = 211
                    self.match(BaseModelicaParser.T__9)
                    pass
                elif token in [6, 11]:
                    pass
                else:
                    pass
                self.state = 215
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==6:
                    self.state = 214
                    self.match(BaseModelicaParser.T__5)


                self.state = 217
                self.match(BaseModelicaParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def longClassSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.LongClassSpecifierContext,0)


        def shortClassSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.ShortClassSpecifierContext,0)


        def derClassSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.DerClassSpecifierContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_classSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSpecifier" ):
                listener.enterClassSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSpecifier" ):
                listener.exitClassSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSpecifier" ):
                return visitor.visitClassSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def classSpecifier(self):

        localctx = BaseModelicaParser.ClassSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_classSpecifier)
        try:
            self.state = 223
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 220
                self.longClassSpecifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 221
                self.shortClassSpecifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 222
                self.derClassSpecifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LongClassSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(BaseModelicaParser.IDENT)
            else:
                return self.getToken(BaseModelicaParser.IDENT, i)

        def stringComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.StringCommentContext,0)


        def composition(self):
            return self.getTypedRuleContext(BaseModelicaParser.CompositionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_longClassSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLongClassSpecifier" ):
                listener.enterLongClassSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLongClassSpecifier" ):
                listener.exitLongClassSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLongClassSpecifier" ):
                return visitor.visitLongClassSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def longClassSpecifier(self):

        localctx = BaseModelicaParser.LongClassSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_longClassSpecifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.match(BaseModelicaParser.IDENT)
            self.state = 226
            self.stringComment()
            self.state = 227
            self.composition()
            self.state = 228
            self.match(BaseModelicaParser.T__3)
            self.state = 229
            self.match(BaseModelicaParser.IDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShortClassSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def typeSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.TypeSpecifierContext,0)


        def basePrefix(self):
            return self.getTypedRuleContext(BaseModelicaParser.BasePrefixContext,0)


        def classModification(self):
            return self.getTypedRuleContext(BaseModelicaParser.ClassModificationContext,0)


        def enumList(self):
            return self.getTypedRuleContext(BaseModelicaParser.EnumListContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_shortClassSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShortClassSpecifier" ):
                listener.enterShortClassSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShortClassSpecifier" ):
                listener.exitShortClassSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShortClassSpecifier" ):
                return visitor.visitShortClassSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def shortClassSpecifier(self):

        localctx = BaseModelicaParser.ShortClassSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_shortClassSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(BaseModelicaParser.IDENT)
            self.state = 232
            self.match(BaseModelicaParser.T__11)
            self.state = 249
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19, 20, 71, 74]:
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19 or _la==20:
                    self.state = 233
                    self.basePrefix()


                self.state = 236
                self.typeSpecifier()
                self.state = 238
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==14:
                    self.state = 237
                    self.classModification()


                pass
            elif token in [13]:
                self.state = 240
                self.match(BaseModelicaParser.T__12)
                self.state = 241
                self.match(BaseModelicaParser.T__13)
                self.state = 246
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [16, 74]:
                    self.state = 243
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==74:
                        self.state = 242
                        self.enumList()


                    pass
                elif token in [15]:
                    self.state = 245
                    self.match(BaseModelicaParser.T__14)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 248
                self.match(BaseModelicaParser.T__15)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 251
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DerClassSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(BaseModelicaParser.IDENT)
            else:
                return self.getToken(BaseModelicaParser.IDENT, i)

        def typeSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.TypeSpecifierContext,0)


        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_derClassSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerClassSpecifier" ):
                listener.enterDerClassSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerClassSpecifier" ):
                listener.exitDerClassSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDerClassSpecifier" ):
                return visitor.visitDerClassSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def derClassSpecifier(self):

        localctx = BaseModelicaParser.DerClassSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_derClassSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.match(BaseModelicaParser.IDENT)
            self.state = 254
            self.match(BaseModelicaParser.T__11)
            self.state = 255
            self.match(BaseModelicaParser.T__16)
            self.state = 256
            self.match(BaseModelicaParser.T__13)
            self.state = 257
            self.typeSpecifier()
            self.state = 258
            self.match(BaseModelicaParser.T__17)
            self.state = 259
            self.match(BaseModelicaParser.IDENT)
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 260
                self.match(BaseModelicaParser.T__17)
                self.state = 261
                self.match(BaseModelicaParser.IDENT)
                self.state = 266
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 267
            self.match(BaseModelicaParser.T__15)
            self.state = 268
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasePrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_basePrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasePrefix" ):
                listener.enterBasePrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasePrefix" ):
                listener.exitBasePrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasePrefix" ):
                return visitor.visitBasePrefix(self)
            else:
                return visitor.visitChildren(self)




    def basePrefix(self):

        localctx = BaseModelicaParser.BasePrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_basePrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            _la = self._input.LA(1)
            if not(_la==19 or _la==20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumerationLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.EnumerationLiteralContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.EnumerationLiteralContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_enumList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumList" ):
                listener.enterEnumList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumList" ):
                listener.exitEnumList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumList" ):
                return visitor.visitEnumList(self)
            else:
                return visitor.visitChildren(self)




    def enumList(self):

        localctx = BaseModelicaParser.EnumListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_enumList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            self.enumerationLiteral()
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 273
                self.match(BaseModelicaParser.T__17)
                self.state = 274
                self.enumerationLiteral()
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumerationLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_enumerationLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumerationLiteral" ):
                listener.enterEnumerationLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumerationLiteral" ):
                listener.exitEnumerationLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumerationLiteral" ):
                return visitor.visitEnumerationLiteral(self)
            else:
                return visitor.visitChildren(self)




    def enumerationLiteral(self):

        localctx = BaseModelicaParser.EnumerationLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_enumerationLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(BaseModelicaParser.IDENT)
            self.state = 281
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.GenericElementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.GenericElementContext,i)


        def basePartition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.BasePartitionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.BasePartitionContext,i)


        def annotationComment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.AnnotationCommentContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.AnnotationCommentContext,i)


        def decoration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.DecorationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,i)


        def equation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.EquationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.EquationContext,i)


        def initialEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.InitialEquationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.InitialEquationContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.StatementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.StatementContext,i)


        def languageSpecification(self):
            return self.getTypedRuleContext(BaseModelicaParser.LanguageSpecificationContext,0)


        def externalFunctionCall(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExternalFunctionCallContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_composition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposition" ):
                listener.enterComposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposition" ):
                listener.exitComposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComposition" ):
                return visitor.visitComposition(self)
            else:
                return visitor.visitChildren(self)




    def composition(self):

        localctx = BaseModelicaParser.CompositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_composition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 284
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==45:
                        self.state = 283
                        self.decoration()


                    self.state = 286
                    self.genericElement()
                    self.state = 287
                    self.match(BaseModelicaParser.T__1) 
                self.state = 293
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 327
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 14680064) != 0):
                self.state = 325
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 294
                    self.match(BaseModelicaParser.T__20)
                    self.state = 300
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,21,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 295
                            self.equation()
                            self.state = 296
                            self.match(BaseModelicaParser.T__1) 
                        self.state = 302
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

                    pass

                elif la_ == 2:
                    self.state = 303
                    self.match(BaseModelicaParser.T__21)
                    self.state = 304
                    self.match(BaseModelicaParser.T__20)
                    self.state = 310
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 305
                            self.initialEquation()
                            self.state = 306
                            self.match(BaseModelicaParser.T__1) 
                        self.state = 312
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

                    pass

                elif la_ == 3:
                    self.state = 314
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==22:
                        self.state = 313
                        self.match(BaseModelicaParser.T__21)


                    self.state = 316
                    self.match(BaseModelicaParser.T__22)
                    self.state = 322
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,24,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 317
                            self.statement()
                            self.state = 318
                            self.match(BaseModelicaParser.T__1) 
                        self.state = 324
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

                    pass


                self.state = 329
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==24 or _la==45:
                self.state = 331
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==45:
                    self.state = 330
                    self.decoration()


                self.state = 333
                self.match(BaseModelicaParser.T__23)
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77:
                    self.state = 334
                    self.languageSpecification()


                self.state = 338
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==71 or _la==74:
                    self.state = 337
                    self.externalFunctionCall()


                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==72:
                    self.state = 340
                    self.annotationComment()


                self.state = 343
                self.match(BaseModelicaParser.T__1)


            self.state = 349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 346
                self.basePartition()
                self.state = 351
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72:
                self.state = 352
                self.annotationComment()
                self.state = 353
                self.match(BaseModelicaParser.T__1)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LanguageSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(BaseModelicaParser.STRING, 0)

        def getRuleIndex(self):
            return BaseModelicaParser.RULE_languageSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLanguageSpecification" ):
                listener.enterLanguageSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLanguageSpecification" ):
                listener.exitLanguageSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLanguageSpecification" ):
                return visitor.visitLanguageSpecification(self)
            else:
                return visitor.visitChildren(self)




    def languageSpecification(self):

        localctx = BaseModelicaParser.LanguageSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_languageSpecification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 357
            self.match(BaseModelicaParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExternalFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def componentReference(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentReferenceContext,0)


        def expressionList(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionListContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_externalFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExternalFunctionCall" ):
                listener.enterExternalFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExternalFunctionCall" ):
                listener.exitExternalFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExternalFunctionCall" ):
                return visitor.visitExternalFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def externalFunctionCall(self):

        localctx = BaseModelicaParser.ExternalFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_externalFunctionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 359
                self.componentReference()
                self.state = 360
                self.match(BaseModelicaParser.T__11)


            self.state = 364
            self.match(BaseModelicaParser.IDENT)
            self.state = 365
            self.match(BaseModelicaParser.T__13)
            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 540713447445381392) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 5719) != 0):
                self.state = 366
                self.expressionList()


            self.state = 369
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def normalElement(self):
            return self.getTypedRuleContext(BaseModelicaParser.NormalElementContext,0)


        def parameterEquation(self):
            return self.getTypedRuleContext(BaseModelicaParser.ParameterEquationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_genericElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericElement" ):
                listener.enterGenericElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericElement" ):
                listener.exitGenericElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericElement" ):
                return visitor.visitGenericElement(self)
            else:
                return visitor.visitChildren(self)




    def genericElement(self):

        localctx = BaseModelicaParser.GenericElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_genericElement)
        try:
            self.state = 373
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 371
                self.normalElement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 372
                self.parameterEquation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NormalElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentClause(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentClauseContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_normalElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNormalElement" ):
                listener.enterNormalElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNormalElement" ):
                listener.exitNormalElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNormalElement" ):
                return visitor.visitNormalElement(self)
            else:
                return visitor.visitChildren(self)




    def normalElement(self):

        localctx = BaseModelicaParser.NormalElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_normalElement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self.componentClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guessValue(self):
            return self.getTypedRuleContext(BaseModelicaParser.GuessValueContext,0)


        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def prioritizeExpression(self):
            return self.getTypedRuleContext(BaseModelicaParser.PrioritizeExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_parameterEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterEquation" ):
                listener.enterParameterEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterEquation" ):
                listener.exitParameterEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterEquation" ):
                return visitor.visitParameterEquation(self)
            else:
                return visitor.visitChildren(self)




    def parameterEquation(self):

        localctx = BaseModelicaParser.ParameterEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_parameterEquation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 377
            self.match(BaseModelicaParser.T__24)
            self.state = 378
            self.match(BaseModelicaParser.T__20)
            self.state = 379
            self.guessValue()
            self.state = 380
            self.match(BaseModelicaParser.T__11)
            self.state = 383
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 8, 14, 17, 22, 34, 48, 55, 56, 57, 58, 65, 66, 67, 69, 71, 74, 75, 77]:
                self.state = 381
                self.expression()
                pass
            elif token in [44]:
                self.state = 382
                self.prioritizeExpression()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 385
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuessValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentReference(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentReferenceContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_guessValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuessValue" ):
                listener.enterGuessValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuessValue" ):
                listener.exitGuessValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuessValue" ):
                return visitor.visitGuessValue(self)
            else:
                return visitor.visitChildren(self)




    def guessValue(self):

        localctx = BaseModelicaParser.GuessValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_guessValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(BaseModelicaParser.T__25)
            self.state = 388
            self.match(BaseModelicaParser.T__13)
            self.state = 389
            self.componentReference()
            self.state = 390
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasePartitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.StringCommentContext,0)


        def annotationComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.AnnotationCommentContext,0)


        def clockClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ClockClauseContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ClockClauseContext,i)


        def subPartition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.SubPartitionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.SubPartitionContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_basePartition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasePartition" ):
                listener.enterBasePartition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasePartition" ):
                listener.exitBasePartition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasePartition" ):
                return visitor.visitBasePartition(self)
            else:
                return visitor.visitChildren(self)




    def basePartition(self):

        localctx = BaseModelicaParser.BasePartitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_basePartition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 392
            self.match(BaseModelicaParser.T__26)
            self.state = 393
            self.stringComment()
            self.state = 397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.state = 394
                self.annotationComment()
                self.state = 395
                self.match(BaseModelicaParser.T__1)


            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29 or _la==45:
                self.state = 399
                self.clockClause()
                self.state = 400
                self.match(BaseModelicaParser.T__1)
                self.state = 406
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==28:
                self.state = 407
                self.subPartition()
                self.state = 412
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubPartitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argumentList(self):
            return self.getTypedRuleContext(BaseModelicaParser.ArgumentListContext,0)


        def stringComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.StringCommentContext,0)


        def annotationComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.AnnotationCommentContext,0)


        def equation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.EquationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.EquationContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.StatementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.StatementContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_subPartition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubPartition" ):
                listener.enterSubPartition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubPartition" ):
                listener.exitSubPartition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubPartition" ):
                return visitor.visitSubPartition(self)
            else:
                return visitor.visitChildren(self)




    def subPartition(self):

        localctx = BaseModelicaParser.SubPartitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_subPartition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.match(BaseModelicaParser.T__27)
            self.state = 414
            self.match(BaseModelicaParser.T__13)
            self.state = 415
            self.argumentList()
            self.state = 416
            self.match(BaseModelicaParser.T__15)
            self.state = 417
            self.stringComment()
            self.state = 421
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.state = 418
                self.annotationComment()
                self.state = 419
                self.match(BaseModelicaParser.T__1)


            self.state = 443
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==21 or _la==23:
                self.state = 441
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [21]:
                    self.state = 423
                    self.match(BaseModelicaParser.T__20)
                    self.state = 429
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 424
                            self.equation()
                            self.state = 425
                            self.match(BaseModelicaParser.T__1) 
                        self.state = 431
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

                    pass
                elif token in [23]:
                    self.state = 432
                    self.match(BaseModelicaParser.T__22)
                    self.state = 438
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                        self.state = 433
                        self.statement()
                        self.state = 434
                        self.match(BaseModelicaParser.T__1)
                        self.state = 440
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 445
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClockClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def decoration(self):
            return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_clockClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClockClause" ):
                listener.enterClockClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClockClause" ):
                listener.exitClockClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClockClause" ):
                return visitor.visitClockClause(self)
            else:
                return visitor.visitChildren(self)




    def clockClause(self):

        localctx = BaseModelicaParser.ClockClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_clockClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 446
                self.decoration()


            self.state = 449
            self.match(BaseModelicaParser.T__28)
            self.state = 450
            self.match(BaseModelicaParser.IDENT)
            self.state = 451
            self.match(BaseModelicaParser.T__11)
            self.state = 452
            self.expression()
            self.state = 453
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComponentClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typePrefix(self):
            return self.getTypedRuleContext(BaseModelicaParser.TypePrefixContext,0)


        def typeSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.TypeSpecifierContext,0)


        def componentList(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentListContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_componentClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponentClause" ):
                listener.enterComponentClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponentClause" ):
                listener.exitComponentClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponentClause" ):
                return visitor.visitComponentClause(self)
            else:
                return visitor.visitChildren(self)




    def componentClause(self):

        localctx = BaseModelicaParser.ComponentClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_componentClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 455
            self.typePrefix()
            self.state = 456
            self.typeSpecifier()
            self.state = 457
            self.componentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GlobalConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.TypeSpecifierContext,0)


        def declaration(self):
            return self.getTypedRuleContext(BaseModelicaParser.DeclarationContext,0)


        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def arraySubscripts(self):
            return self.getTypedRuleContext(BaseModelicaParser.ArraySubscriptsContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_globalConstant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGlobalConstant" ):
                listener.enterGlobalConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGlobalConstant" ):
                listener.exitGlobalConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGlobalConstant" ):
                return visitor.visitGlobalConstant(self)
            else:
                return visitor.visitChildren(self)




    def globalConstant(self):

        localctx = BaseModelicaParser.GlobalConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_globalConstant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            self.match(BaseModelicaParser.T__8)
            self.state = 460
            self.typeSpecifier()
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 461
                self.arraySubscripts()


            self.state = 464
            self.declaration()
            self.state = 465
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypePrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_typePrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypePrefix" ):
                listener.enterTypePrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypePrefix" ):
                listener.exitTypePrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypePrefix" ):
                return visitor.visitTypePrefix(self)
            else:
                return visitor.visitChildren(self)




    def typePrefix(self):

        localctx = BaseModelicaParser.TypePrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_typePrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1107296768) != 0):
                self.state = 467
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1107296768) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 471
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19 or _la==20:
                self.state = 470
                _la = self._input.LA(1)
                if not(_la==19 or _la==20):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComponentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ComponentDeclarationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ComponentDeclarationContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_componentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponentList" ):
                listener.enterComponentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponentList" ):
                listener.exitComponentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponentList" ):
                return visitor.visitComponentList(self)
            else:
                return visitor.visitChildren(self)




    def componentList(self):

        localctx = BaseModelicaParser.ComponentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_componentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self.componentDeclaration()
            self.state = 478
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 474
                self.match(BaseModelicaParser.T__17)
                self.state = 475
                self.componentDeclaration()
                self.state = 480
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComponentDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self):
            return self.getTypedRuleContext(BaseModelicaParser.DeclarationContext,0)


        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_componentDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponentDeclaration" ):
                listener.enterComponentDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponentDeclaration" ):
                listener.exitComponentDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponentDeclaration" ):
                return visitor.visitComponentDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def componentDeclaration(self):

        localctx = BaseModelicaParser.ComponentDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_componentDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            self.declaration()
            self.state = 482
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def arraySubscripts(self):
            return self.getTypedRuleContext(BaseModelicaParser.ArraySubscriptsContext,0)


        def modification(self):
            return self.getTypedRuleContext(BaseModelicaParser.ModificationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = BaseModelicaParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 484
            self.match(BaseModelicaParser.IDENT)
            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 485
                self.arraySubscripts()


            self.state = 489
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2147504128) != 0):
                self.state = 488
                self.modification()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classModification(self):
            return self.getTypedRuleContext(BaseModelicaParser.ClassModificationContext,0)


        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_modification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModification" ):
                listener.enterModification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModification" ):
                listener.exitModification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModification" ):
                return visitor.visitModification(self)
            else:
                return visitor.visitChildren(self)




    def modification(self):

        localctx = BaseModelicaParser.ModificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_modification)
        self._la = 0 # Token type
        try:
            self.state = 500
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 491
                self.classModification()
                self.state = 494
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==12:
                    self.state = 492
                    self.match(BaseModelicaParser.T__11)
                    self.state = 493
                    self.expression()


                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 2)
                self.state = 496
                self.match(BaseModelicaParser.T__11)
                self.state = 497
                self.expression()
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 3)
                self.state = 498
                self.match(BaseModelicaParser.T__30)
                self.state = 499
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassModificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argumentList(self):
            return self.getTypedRuleContext(BaseModelicaParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_classModification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassModification" ):
                listener.enterClassModification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassModification" ):
                listener.exitClassModification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassModification" ):
                return visitor.visitClassModification(self)
            else:
                return visitor.visitChildren(self)




    def classModification(self):

        localctx = BaseModelicaParser.ClassModificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_classModification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 502
            self.match(BaseModelicaParser.T__13)
            self.state = 504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45 or _la==74:
                self.state = 503
                self.argumentList()


            self.state = 506
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ArgumentContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = BaseModelicaParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self.argument()
            self.state = 513
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 509
                self.match(BaseModelicaParser.T__17)
                self.state = 510
                self.argument()
                self.state = 515
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementModificationOrReplaceable(self):
            return self.getTypedRuleContext(BaseModelicaParser.ElementModificationOrReplaceableContext,0)


        def decoration(self):
            return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgument" ):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = BaseModelicaParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_argument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 516
                self.decoration()


            self.state = 519
            self.elementModificationOrReplaceable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementModificationOrReplaceableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementModification(self):
            return self.getTypedRuleContext(BaseModelicaParser.ElementModificationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_elementModificationOrReplaceable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementModificationOrReplaceable" ):
                listener.enterElementModificationOrReplaceable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementModificationOrReplaceable" ):
                listener.exitElementModificationOrReplaceable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementModificationOrReplaceable" ):
                return visitor.visitElementModificationOrReplaceable(self)
            else:
                return visitor.visitChildren(self)




    def elementModificationOrReplaceable(self):

        localctx = BaseModelicaParser.ElementModificationOrReplaceableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_elementModificationOrReplaceable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 521
            self.elementModification()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementModificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(BaseModelicaParser.NameContext,0)


        def stringComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.StringCommentContext,0)


        def modification(self):
            return self.getTypedRuleContext(BaseModelicaParser.ModificationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_elementModification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementModification" ):
                listener.enterElementModification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementModification" ):
                listener.exitElementModification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementModification" ):
                return visitor.visitElementModification(self)
            else:
                return visitor.visitChildren(self)




    def elementModification(self):

        localctx = BaseModelicaParser.ElementModificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_elementModification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 523
            self.name()
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2147504128) != 0):
                self.state = 524
                self.modification()


            self.state = 527
            self.stringComment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def simpleExpression(self):
            return self.getTypedRuleContext(BaseModelicaParser.SimpleExpressionContext,0)


        def ifEquation(self):
            return self.getTypedRuleContext(BaseModelicaParser.IfEquationContext,0)


        def forEquation(self):
            return self.getTypedRuleContext(BaseModelicaParser.ForEquationContext,0)


        def whenEquation(self):
            return self.getTypedRuleContext(BaseModelicaParser.WhenEquationContext,0)


        def decoration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.DecorationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,i)


        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_equation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquation" ):
                listener.enterEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquation" ):
                listener.exitEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquation" ):
                return visitor.visitEquation(self)
            else:
                return visitor.visitChildren(self)




    def equation(self):

        localctx = BaseModelicaParser.EquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_equation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 529
                self.decoration()


            self.state = 543
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 8, 14, 17, 22, 48, 55, 56, 57, 58, 65, 66, 67, 69, 71, 74, 75, 77]:
                self.state = 532
                self.simpleExpression()
                self.state = 534
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==45:
                    self.state = 533
                    self.decoration()


                self.state = 538
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==12:
                    self.state = 536
                    self.match(BaseModelicaParser.T__11)
                    self.state = 537
                    self.expression()


                pass
            elif token in [34]:
                self.state = 540
                self.ifEquation()
                pass
            elif token in [38]:
                self.state = 541
                self.forEquation()
                pass
            elif token in [42]:
                self.state = 542
                self.whenEquation()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 545
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitialEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equation(self):
            return self.getTypedRuleContext(BaseModelicaParser.EquationContext,0)


        def prioritizeEquation(self):
            return self.getTypedRuleContext(BaseModelicaParser.PrioritizeEquationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_initialEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialEquation" ):
                listener.enterInitialEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialEquation" ):
                listener.exitInitialEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitialEquation" ):
                return visitor.visitInitialEquation(self)
            else:
                return visitor.visitChildren(self)




    def initialEquation(self):

        localctx = BaseModelicaParser.InitialEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_initialEquation)
        try:
            self.state = 549
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 8, 14, 17, 22, 34, 38, 42, 45, 48, 55, 56, 57, 58, 65, 66, 67, 69, 71, 74, 75, 77]:
                self.enterOuterAlt(localctx, 1)
                self.state = 547
                self.equation()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 548
                self.prioritizeEquation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comment(self):
            return self.getTypedRuleContext(BaseModelicaParser.CommentContext,0)


        def componentReference(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentReferenceContext,0)


        def outputExpressionList(self):
            return self.getTypedRuleContext(BaseModelicaParser.OutputExpressionListContext,0)


        def functionCallArgs(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionCallArgsContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(BaseModelicaParser.IfStatementContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(BaseModelicaParser.ForStatementContext,0)


        def whileStatement(self):
            return self.getTypedRuleContext(BaseModelicaParser.WhileStatementContext,0)


        def whenStatement(self):
            return self.getTypedRuleContext(BaseModelicaParser.WhenStatementContext,0)


        def decoration(self):
            return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,0)


        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = BaseModelicaParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 551
                self.decoration()


            self.state = 573
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [71, 74]:
                self.state = 554
                self.componentReference()
                self.state = 558
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [31]:
                    self.state = 555
                    self.match(BaseModelicaParser.T__30)
                    self.state = 556
                    self.expression()
                    pass
                elif token in [14]:
                    self.state = 557
                    self.functionCallArgs()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [14]:
                self.state = 560
                self.match(BaseModelicaParser.T__13)
                self.state = 561
                self.outputExpressionList()
                self.state = 562
                self.match(BaseModelicaParser.T__15)
                self.state = 563
                self.match(BaseModelicaParser.T__30)
                self.state = 564
                self.componentReference()
                self.state = 565
                self.functionCallArgs()
                pass
            elif token in [32]:
                self.state = 567
                self.match(BaseModelicaParser.T__31)
                pass
            elif token in [33]:
                self.state = 568
                self.match(BaseModelicaParser.T__32)
                pass
            elif token in [34]:
                self.state = 569
                self.ifStatement()
                pass
            elif token in [38]:
                self.state = 570
                self.forStatement()
                pass
            elif token in [41]:
                self.state = 571
                self.whileStatement()
                pass
            elif token in [42]:
                self.state = 572
                self.whenStatement()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 575
            self.comment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def equation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.EquationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.EquationContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_ifEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfEquation" ):
                listener.enterIfEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfEquation" ):
                listener.exitIfEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfEquation" ):
                return visitor.visitIfEquation(self)
            else:
                return visitor.visitChildren(self)




    def ifEquation(self):

        localctx = BaseModelicaParser.IfEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_ifEquation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 577
            self.match(BaseModelicaParser.T__33)
            self.state = 578
            self.expression()
            self.state = 579
            self.match(BaseModelicaParser.T__34)
            self.state = 585
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,67,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 580
                    self.equation()
                    self.state = 581
                    self.match(BaseModelicaParser.T__1) 
                self.state = 587
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,67,self._ctx)

            self.state = 601
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==36:
                self.state = 588
                self.match(BaseModelicaParser.T__35)
                self.state = 589
                self.expression()
                self.state = 590
                self.match(BaseModelicaParser.T__34)
                self.state = 596
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,68,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 591
                        self.equation()
                        self.state = 592
                        self.match(BaseModelicaParser.T__1) 
                    self.state = 598
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,68,self._ctx)

                self.state = 603
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 613
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 604
                self.match(BaseModelicaParser.T__36)
                self.state = 610
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,70,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 605
                        self.equation()
                        self.state = 606
                        self.match(BaseModelicaParser.T__1) 
                    self.state = 612
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,70,self._ctx)



            self.state = 615
            self.match(BaseModelicaParser.T__3)
            self.state = 616
            self.match(BaseModelicaParser.T__33)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.StatementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.StatementContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = BaseModelicaParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_ifStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 618
            self.match(BaseModelicaParser.T__33)
            self.state = 619
            self.expression()
            self.state = 620
            self.match(BaseModelicaParser.T__34)
            self.state = 626
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                self.state = 621
                self.statement()
                self.state = 622
                self.match(BaseModelicaParser.T__1)
                self.state = 628
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 642
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==36:
                self.state = 629
                self.match(BaseModelicaParser.T__35)
                self.state = 630
                self.expression()
                self.state = 631
                self.match(BaseModelicaParser.T__34)
                self.state = 637
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                    self.state = 632
                    self.statement()
                    self.state = 633
                    self.match(BaseModelicaParser.T__1)
                    self.state = 639
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 644
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 654
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 645
                self.match(BaseModelicaParser.T__36)
                self.state = 651
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                    self.state = 646
                    self.statement()
                    self.state = 647
                    self.match(BaseModelicaParser.T__1)
                    self.state = 653
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 656
            self.match(BaseModelicaParser.T__3)
            self.state = 657
            self.match(BaseModelicaParser.T__33)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forIndex(self):
            return self.getTypedRuleContext(BaseModelicaParser.ForIndexContext,0)


        def equation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.EquationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.EquationContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_forEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForEquation" ):
                listener.enterForEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForEquation" ):
                listener.exitForEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForEquation" ):
                return visitor.visitForEquation(self)
            else:
                return visitor.visitChildren(self)




    def forEquation(self):

        localctx = BaseModelicaParser.ForEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_forEquation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.match(BaseModelicaParser.T__37)
            self.state = 660
            self.forIndex()
            self.state = 661
            self.match(BaseModelicaParser.T__38)
            self.state = 667
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,77,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 662
                    self.equation()
                    self.state = 663
                    self.match(BaseModelicaParser.T__1) 
                self.state = 669
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,77,self._ctx)

            self.state = 670
            self.match(BaseModelicaParser.T__3)
            self.state = 671
            self.match(BaseModelicaParser.T__37)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forIndex(self):
            return self.getTypedRuleContext(BaseModelicaParser.ForIndexContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.StatementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.StatementContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_forStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStatement" ):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)




    def forStatement(self):

        localctx = BaseModelicaParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_forStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 673
            self.match(BaseModelicaParser.T__37)
            self.state = 674
            self.forIndex()
            self.state = 675
            self.match(BaseModelicaParser.T__38)
            self.state = 681
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                self.state = 676
                self.statement()
                self.state = 677
                self.match(BaseModelicaParser.T__1)
                self.state = 683
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 684
            self.match(BaseModelicaParser.T__3)
            self.state = 685
            self.match(BaseModelicaParser.T__37)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForIndexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_forIndex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForIndex" ):
                listener.enterForIndex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForIndex" ):
                listener.exitForIndex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForIndex" ):
                return visitor.visitForIndex(self)
            else:
                return visitor.visitChildren(self)




    def forIndex(self):

        localctx = BaseModelicaParser.ForIndexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_forIndex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 687
            self.match(BaseModelicaParser.IDENT)
            self.state = 688
            self.match(BaseModelicaParser.T__39)
            self.state = 689
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.StatementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.StatementContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_whileStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStatement" ):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)




    def whileStatement(self):

        localctx = BaseModelicaParser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_whileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.match(BaseModelicaParser.T__40)
            self.state = 692
            self.expression()
            self.state = 693
            self.match(BaseModelicaParser.T__38)
            self.state = 699
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                self.state = 694
                self.statement()
                self.state = 695
                self.match(BaseModelicaParser.T__1)
                self.state = 701
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 702
            self.match(BaseModelicaParser.T__3)
            self.state = 703
            self.match(BaseModelicaParser.T__40)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def equation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.EquationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.EquationContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_whenEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenEquation" ):
                listener.enterWhenEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenEquation" ):
                listener.exitWhenEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenEquation" ):
                return visitor.visitWhenEquation(self)
            else:
                return visitor.visitChildren(self)




    def whenEquation(self):

        localctx = BaseModelicaParser.WhenEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_whenEquation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 705
            self.match(BaseModelicaParser.T__41)
            self.state = 706
            self.expression()
            self.state = 707
            self.match(BaseModelicaParser.T__34)
            self.state = 713
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,80,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 708
                    self.equation()
                    self.state = 709
                    self.match(BaseModelicaParser.T__1) 
                self.state = 715
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,80,self._ctx)

            self.state = 729
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43:
                self.state = 716
                self.match(BaseModelicaParser.T__42)
                self.state = 717
                self.expression()
                self.state = 718
                self.match(BaseModelicaParser.T__34)
                self.state = 724
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 719
                        self.equation()
                        self.state = 720
                        self.match(BaseModelicaParser.T__1) 
                    self.state = 726
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

                self.state = 731
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 732
            self.match(BaseModelicaParser.T__3)
            self.state = 733
            self.match(BaseModelicaParser.T__41)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.StatementContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.StatementContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_whenStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenStatement" ):
                listener.enterWhenStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenStatement" ):
                listener.exitWhenStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenStatement" ):
                return visitor.visitWhenStatement(self)
            else:
                return visitor.visitChildren(self)




    def whenStatement(self):

        localctx = BaseModelicaParser.WhenStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_whenStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 735
            self.match(BaseModelicaParser.T__41)
            self.state = 736
            self.expression()
            self.state = 737
            self.match(BaseModelicaParser.T__34)
            self.state = 743
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                self.state = 738
                self.statement()
                self.state = 739
                self.match(BaseModelicaParser.T__1)
                self.state = 745
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 759
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43:
                self.state = 746
                self.match(BaseModelicaParser.T__42)
                self.state = 747
                self.expression()
                self.state = 748
                self.match(BaseModelicaParser.T__34)
                self.state = 754
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & 1297036695251451905) != 0):
                    self.state = 749
                    self.statement()
                    self.state = 750
                    self.match(BaseModelicaParser.T__1)
                    self.state = 756
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 761
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 762
            self.match(BaseModelicaParser.T__3)
            self.state = 763
            self.match(BaseModelicaParser.T__41)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrioritizeEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentReference(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentReferenceContext,0)


        def priority(self):
            return self.getTypedRuleContext(BaseModelicaParser.PriorityContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_prioritizeEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrioritizeEquation" ):
                listener.enterPrioritizeEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrioritizeEquation" ):
                listener.exitPrioritizeEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrioritizeEquation" ):
                return visitor.visitPrioritizeEquation(self)
            else:
                return visitor.visitChildren(self)




    def prioritizeEquation(self):

        localctx = BaseModelicaParser.PrioritizeEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_prioritizeEquation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 765
            self.match(BaseModelicaParser.T__43)
            self.state = 766
            self.match(BaseModelicaParser.T__13)
            self.state = 767
            self.componentReference()
            self.state = 768
            self.match(BaseModelicaParser.T__17)
            self.state = 769
            self.priority()
            self.state = 770
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrioritizeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def priority(self):
            return self.getTypedRuleContext(BaseModelicaParser.PriorityContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_prioritizeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrioritizeExpression" ):
                listener.enterPrioritizeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrioritizeExpression" ):
                listener.exitPrioritizeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrioritizeExpression" ):
                return visitor.visitPrioritizeExpression(self)
            else:
                return visitor.visitChildren(self)




    def prioritizeExpression(self):

        localctx = BaseModelicaParser.PrioritizeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_prioritizeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 772
            self.match(BaseModelicaParser.T__43)
            self.state = 773
            self.match(BaseModelicaParser.T__13)
            self.state = 774
            self.expression()
            self.state = 775
            self.match(BaseModelicaParser.T__17)
            self.state = 776
            self.priority()
            self.state = 777
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PriorityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_priority

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPriority" ):
                listener.enterPriority(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPriority" ):
                listener.exitPriority(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPriority" ):
                return visitor.visitPriority(self)
            else:
                return visitor.visitChildren(self)




    def priority(self):

        localctx = BaseModelicaParser.PriorityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_priority)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 779
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecorationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INTEGER(self):
            return self.getToken(BaseModelicaParser.UNSIGNED_INTEGER, 0)

        def getRuleIndex(self):
            return BaseModelicaParser.RULE_decoration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoration" ):
                listener.enterDecoration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoration" ):
                listener.exitDecoration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoration" ):
                return visitor.visitDecoration(self)
            else:
                return visitor.visitChildren(self)




    def decoration(self):

        localctx = BaseModelicaParser.DecorationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_decoration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 781
            self.match(BaseModelicaParser.T__44)
            self.state = 782
            self.match(BaseModelicaParser.UNSIGNED_INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionNoDecoration(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionNoDecorationContext,0)


        def decoration(self):
            return self.getTypedRuleContext(BaseModelicaParser.DecorationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = BaseModelicaParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 784
            self.expressionNoDecoration()
            self.state = 786
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 785
                self.decoration()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionNoDecorationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleExpression(self):
            return self.getTypedRuleContext(BaseModelicaParser.SimpleExpressionContext,0)


        def ifExpression(self):
            return self.getTypedRuleContext(BaseModelicaParser.IfExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_expressionNoDecoration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionNoDecoration" ):
                listener.enterExpressionNoDecoration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionNoDecoration" ):
                listener.exitExpressionNoDecoration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionNoDecoration" ):
                return visitor.visitExpressionNoDecoration(self)
            else:
                return visitor.visitChildren(self)




    def expressionNoDecoration(self):

        localctx = BaseModelicaParser.ExpressionNoDecorationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_expressionNoDecoration)
        try:
            self.state = 790
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 8, 14, 17, 22, 48, 55, 56, 57, 58, 65, 66, 67, 69, 71, 74, 75, 77]:
                self.enterOuterAlt(localctx, 1)
                self.state = 788
                self.simpleExpression()
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 2)
                self.state = 789
                self.ifExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionNoDecoration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionNoDecorationContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionNoDecorationContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_ifExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExpression" ):
                listener.enterIfExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExpression" ):
                listener.exitIfExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExpression" ):
                return visitor.visitIfExpression(self)
            else:
                return visitor.visitChildren(self)




    def ifExpression(self):

        localctx = BaseModelicaParser.IfExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_ifExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.match(BaseModelicaParser.T__33)
            self.state = 793
            self.expressionNoDecoration()
            self.state = 794
            self.match(BaseModelicaParser.T__34)
            self.state = 795
            self.expressionNoDecoration()
            self.state = 803
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==36:
                self.state = 796
                self.match(BaseModelicaParser.T__35)
                self.state = 797
                self.expressionNoDecoration()
                self.state = 798
                self.match(BaseModelicaParser.T__34)
                self.state = 799
                self.expressionNoDecoration()
                self.state = 805
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 806
            self.match(BaseModelicaParser.T__36)
            self.state = 807
            self.expressionNoDecoration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.LogicalExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.LogicalExpressionContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_simpleExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpression" ):
                listener.enterSimpleExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpression" ):
                listener.exitSimpleExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpression" ):
                return visitor.visitSimpleExpression(self)
            else:
                return visitor.visitChildren(self)




    def simpleExpression(self):

        localctx = BaseModelicaParser.SimpleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_simpleExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 809
            self.logicalExpression()
            self.state = 816
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 810
                self.match(BaseModelicaParser.T__14)
                self.state = 811
                self.logicalExpression()
                self.state = 814
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==15:
                    self.state = 812
                    self.match(BaseModelicaParser.T__14)
                    self.state = 813
                    self.logicalExpression()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.LogicalTermContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.LogicalTermContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_logicalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpression" ):
                listener.enterLogicalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpression" ):
                listener.exitLogicalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpression" ):
                return visitor.visitLogicalExpression(self)
            else:
                return visitor.visitChildren(self)




    def logicalExpression(self):

        localctx = BaseModelicaParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_logicalExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self.logicalTerm()
            self.state = 823
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 819
                self.match(BaseModelicaParser.T__45)
                self.state = 820
                self.logicalTerm()
                self.state = 825
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalFactor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.LogicalFactorContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.LogicalFactorContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_logicalTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalTerm" ):
                listener.enterLogicalTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalTerm" ):
                listener.exitLogicalTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalTerm" ):
                return visitor.visitLogicalTerm(self)
            else:
                return visitor.visitChildren(self)




    def logicalTerm(self):

        localctx = BaseModelicaParser.LogicalTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_logicalTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 826
            self.logicalFactor()
            self.state = 831
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==47:
                self.state = 827
                self.match(BaseModelicaParser.T__46)
                self.state = 828
                self.logicalFactor()
                self.state = 833
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalFactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relation(self):
            return self.getTypedRuleContext(BaseModelicaParser.RelationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_logicalFactor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalFactor" ):
                listener.enterLogicalFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalFactor" ):
                listener.exitLogicalFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalFactor" ):
                return visitor.visitLogicalFactor(self)
            else:
                return visitor.visitChildren(self)




    def logicalFactor(self):

        localctx = BaseModelicaParser.LogicalFactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_logicalFactor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 835
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 834
                self.match(BaseModelicaParser.T__47)


            self.state = 837
            self.relation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arithmeticExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ArithmeticExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ArithmeticExpressionContext,i)


        def relationalOperator(self):
            return self.getTypedRuleContext(BaseModelicaParser.RelationalOperatorContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelation" ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = BaseModelicaParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_relation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 839
            self.arithmeticExpression()
            self.state = 843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 35465847065542656) != 0):
                self.state = 840
                self.relationalOperator()
                self.state = 841
                self.arithmeticExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_relationalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalOperator" ):
                listener.enterRelationalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalOperator" ):
                listener.exitRelationalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationalOperator" ):
                return visitor.visitRelationalOperator(self)
            else:
                return visitor.visitChildren(self)




    def relationalOperator(self):

        localctx = BaseModelicaParser.RelationalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_relationalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 35465847065542656) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.TermContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.TermContext,i)


        def addOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.AddOperatorContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.AddOperatorContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_arithmeticExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticExpression" ):
                listener.enterArithmeticExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticExpression" ):
                listener.exitArithmeticExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticExpression" ):
                return visitor.visitArithmeticExpression(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticExpression(self):

        localctx = BaseModelicaParser.ArithmeticExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_arithmeticExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 848
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 540431955284459520) != 0):
                self.state = 847
                self.addOperator()


            self.state = 850
            self.term()
            self.state = 856
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 540431955284459520) != 0):
                self.state = 851
                self.addOperator()
                self.state = 852
                self.term()
                self.state = 858
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_addOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddOperator" ):
                listener.enterAddOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddOperator" ):
                listener.exitAddOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddOperator" ):
                return visitor.visitAddOperator(self)
            else:
                return visitor.visitChildren(self)




    def addOperator(self):

        localctx = BaseModelicaParser.AddOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_addOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 859
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 540431955284459520) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.FactorContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.FactorContext,i)


        def mulOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.MulOperatorContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.MulOperatorContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = BaseModelicaParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 861
            self.factor()
            self.state = 867
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 8646911284551352320) != 0):
                self.state = 862
                self.mulOperator()
                self.state = 863
                self.factor()
                self.state = 869
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MulOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_mulOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulOperator" ):
                listener.enterMulOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulOperator" ):
                listener.exitMulOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMulOperator" ):
                return visitor.visitMulOperator(self)
            else:
                return visitor.visitChildren(self)




    def mulOperator(self):

        localctx = BaseModelicaParser.MulOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_mulOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 870
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8646911284551352320) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.PrimaryContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.PrimaryContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = BaseModelicaParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_factor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 872
            self.primary()
            self.state = 875
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==63 or _la==64:
                self.state = 873
                _la = self._input.LA(1)
                if not(_la==63 or _la==64):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 874
                self.primary()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_NUMBER(self):
            return self.getToken(BaseModelicaParser.UNSIGNED_NUMBER, 0)

        def STRING(self):
            return self.getToken(BaseModelicaParser.STRING, 0)

        def functionCallArgs(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionCallArgsContext,0)


        def componentReference(self):
            return self.getTypedRuleContext(BaseModelicaParser.ComponentReferenceContext,0)


        def outputExpressionList(self):
            return self.getTypedRuleContext(BaseModelicaParser.OutputExpressionListContext,0)


        def arraySubscripts(self):
            return self.getTypedRuleContext(BaseModelicaParser.ArraySubscriptsContext,0)


        def expressionList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionListContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionListContext,i)


        def arrayArguments(self):
            return self.getTypedRuleContext(BaseModelicaParser.ArrayArgumentsContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary" ):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)




    def primary(self):

        localctx = BaseModelicaParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_primary)
        self._la = 0 # Token type
        try:
            self.state = 909
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [75]:
                self.enterOuterAlt(localctx, 1)
                self.state = 877
                self.match(BaseModelicaParser.UNSIGNED_NUMBER)
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 878
                self.match(BaseModelicaParser.STRING)
                pass
            elif token in [65]:
                self.enterOuterAlt(localctx, 3)
                self.state = 879
                self.match(BaseModelicaParser.T__64)
                pass
            elif token in [66]:
                self.enterOuterAlt(localctx, 4)
                self.state = 880
                self.match(BaseModelicaParser.T__65)
                pass
            elif token in [8, 17, 22]:
                self.enterOuterAlt(localctx, 5)
                self.state = 881
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4325632) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 882
                self.functionCallArgs()
                pass
            elif token in [71, 74]:
                self.enterOuterAlt(localctx, 6)
                self.state = 883
                self.componentReference()
                self.state = 885
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==14:
                    self.state = 884
                    self.functionCallArgs()


                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 7)
                self.state = 887
                self.match(BaseModelicaParser.T__13)
                self.state = 888
                self.outputExpressionList()
                self.state = 889
                self.match(BaseModelicaParser.T__15)
                self.state = 891
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==67:
                    self.state = 890
                    self.arraySubscripts()


                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 8)
                self.state = 893
                self.match(BaseModelicaParser.T__66)
                self.state = 894
                self.expressionList()
                self.state = 899
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 895
                    self.match(BaseModelicaParser.T__1)
                    self.state = 896
                    self.expressionList()
                    self.state = 901
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 902
                self.match(BaseModelicaParser.T__67)
                pass
            elif token in [69]:
                self.enterOuterAlt(localctx, 9)
                self.state = 904
                self.match(BaseModelicaParser.T__68)
                self.state = 905
                self.arrayArguments()
                self.state = 906
                self.match(BaseModelicaParser.T__69)
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 10)
                self.state = 908
                self.match(BaseModelicaParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(BaseModelicaParser.NameContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_typeSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSpecifier" ):
                listener.enterTypeSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSpecifier" ):
                listener.exitTypeSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeSpecifier" ):
                return visitor.visitTypeSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def typeSpecifier(self):

        localctx = BaseModelicaParser.TypeSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_typeSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 912
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 911
                self.match(BaseModelicaParser.T__70)


            self.state = 914
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(BaseModelicaParser.IDENT)
            else:
                return self.getToken(BaseModelicaParser.IDENT, i)

        def getRuleIndex(self):
            return BaseModelicaParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = BaseModelicaParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 916
            self.match(BaseModelicaParser.IDENT)
            self.state = 921
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==71:
                self.state = 917
                self.match(BaseModelicaParser.T__70)
                self.state = 918
                self.match(BaseModelicaParser.IDENT)
                self.state = 923
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComponentReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(BaseModelicaParser.IDENT)
            else:
                return self.getToken(BaseModelicaParser.IDENT, i)

        def arraySubscripts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ArraySubscriptsContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ArraySubscriptsContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_componentReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComponentReference" ):
                listener.enterComponentReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComponentReference" ):
                listener.exitComponentReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComponentReference" ):
                return visitor.visitComponentReference(self)
            else:
                return visitor.visitChildren(self)




    def componentReference(self):

        localctx = BaseModelicaParser.ComponentReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_componentReference)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 925
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 924
                self.match(BaseModelicaParser.T__70)


            self.state = 927
            self.match(BaseModelicaParser.IDENT)
            self.state = 929
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==67:
                self.state = 928
                self.arraySubscripts()


            self.state = 938
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==71:
                self.state = 931
                self.match(BaseModelicaParser.T__70)
                self.state = 932
                self.match(BaseModelicaParser.IDENT)
                self.state = 934
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==67:
                    self.state = 933
                    self.arraySubscripts()


                self.state = 940
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionArguments(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionArgumentsContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_functionCallArgs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCallArgs" ):
                listener.enterFunctionCallArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCallArgs" ):
                listener.exitFunctionCallArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCallArgs" ):
                return visitor.visitFunctionCallArgs(self)
            else:
                return visitor.visitChildren(self)




    def functionCallArgs(self):

        localctx = BaseModelicaParser.FunctionCallArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_functionCallArgs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 941
            self.match(BaseModelicaParser.T__13)
            self.state = 943
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 540713447445383440) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 5719) != 0):
                self.state = 942
                self.functionArguments()


            self.state = 945
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def functionArgumentsNonFirst(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionArgumentsNonFirstContext,0)


        def forIndex(self):
            return self.getTypedRuleContext(BaseModelicaParser.ForIndexContext,0)


        def functionPartialApplication(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionPartialApplicationContext,0)


        def namedArguments(self):
            return self.getTypedRuleContext(BaseModelicaParser.NamedArgumentsContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_functionArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionArguments" ):
                listener.enterFunctionArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionArguments" ):
                listener.exitFunctionArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionArguments" ):
                return visitor.visitFunctionArguments(self)
            else:
                return visitor.visitChildren(self)




    def functionArguments(self):

        localctx = BaseModelicaParser.FunctionArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_functionArguments)
        self._la = 0 # Token type
        try:
            self.state = 960
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 947
                self.expression()
                self.state = 952
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [18]:
                    self.state = 948
                    self.match(BaseModelicaParser.T__17)
                    self.state = 949
                    self.functionArgumentsNonFirst()
                    pass
                elif token in [38]:
                    self.state = 950
                    self.match(BaseModelicaParser.T__37)
                    self.state = 951
                    self.forIndex()
                    pass
                elif token in [16]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 954
                self.functionPartialApplication()
                self.state = 957
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==18:
                    self.state = 955
                    self.match(BaseModelicaParser.T__17)
                    self.state = 956
                    self.functionArgumentsNonFirst()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 959
                self.namedArguments()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionArgumentsNonFirstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionArgument(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionArgumentContext,0)


        def functionArgumentsNonFirst(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionArgumentsNonFirstContext,0)


        def namedArguments(self):
            return self.getTypedRuleContext(BaseModelicaParser.NamedArgumentsContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_functionArgumentsNonFirst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionArgumentsNonFirst" ):
                listener.enterFunctionArgumentsNonFirst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionArgumentsNonFirst" ):
                listener.exitFunctionArgumentsNonFirst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionArgumentsNonFirst" ):
                return visitor.visitFunctionArgumentsNonFirst(self)
            else:
                return visitor.visitChildren(self)




    def functionArgumentsNonFirst(self):

        localctx = BaseModelicaParser.FunctionArgumentsNonFirstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_functionArgumentsNonFirst)
        self._la = 0 # Token type
        try:
            self.state = 968
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 962
                self.functionArgument()
                self.state = 965
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==18:
                    self.state = 963
                    self.match(BaseModelicaParser.T__17)
                    self.state = 964
                    self.functionArgumentsNonFirst()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 967
                self.namedArguments()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def forIndex(self):
            return self.getTypedRuleContext(BaseModelicaParser.ForIndexContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_arrayArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayArguments" ):
                listener.enterArrayArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayArguments" ):
                listener.exitArrayArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayArguments" ):
                return visitor.visitArrayArguments(self)
            else:
                return visitor.visitChildren(self)




    def arrayArguments(self):

        localctx = BaseModelicaParser.ArrayArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_arrayArguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 970
            self.expression()
            self.state = 980
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [18, 70]:
                self.state = 975
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 971
                    self.match(BaseModelicaParser.T__17)
                    self.state = 972
                    self.expression()
                    self.state = 977
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [38]:
                self.state = 978
                self.match(BaseModelicaParser.T__37)
                self.state = 979
                self.forIndex()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.NamedArgumentContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_namedArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedArguments" ):
                listener.enterNamedArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedArguments" ):
                listener.exitNamedArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArguments" ):
                return visitor.visitNamedArguments(self)
            else:
                return visitor.visitChildren(self)




    def namedArguments(self):

        localctx = BaseModelicaParser.NamedArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_namedArguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 982
            self.namedArgument()
            self.state = 987
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 983
                self.match(BaseModelicaParser.T__17)
                self.state = 984
                self.namedArgument()
                self.state = 989
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(BaseModelicaParser.IDENT, 0)

        def functionArgument(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionArgumentContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_namedArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedArgument" ):
                listener.enterNamedArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedArgument" ):
                listener.exitNamedArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArgument" ):
                return visitor.visitNamedArgument(self)
            else:
                return visitor.visitChildren(self)




    def namedArgument(self):

        localctx = BaseModelicaParser.NamedArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_namedArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 990
            self.match(BaseModelicaParser.IDENT)
            self.state = 991
            self.match(BaseModelicaParser.T__11)
            self.state = 992
            self.functionArgument()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionPartialApplication(self):
            return self.getTypedRuleContext(BaseModelicaParser.FunctionPartialApplicationContext,0)


        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_functionArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionArgument" ):
                listener.enterFunctionArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionArgument" ):
                listener.exitFunctionArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionArgument" ):
                return visitor.visitFunctionArgument(self)
            else:
                return visitor.visitChildren(self)




    def functionArgument(self):

        localctx = BaseModelicaParser.FunctionArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_functionArgument)
        try:
            self.state = 996
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [11]:
                self.enterOuterAlt(localctx, 1)
                self.state = 994
                self.functionPartialApplication()
                pass
            elif token in [4, 8, 14, 17, 22, 34, 48, 55, 56, 57, 58, 65, 66, 67, 69, 71, 74, 75, 77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 995
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionPartialApplicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeSpecifier(self):
            return self.getTypedRuleContext(BaseModelicaParser.TypeSpecifierContext,0)


        def namedArguments(self):
            return self.getTypedRuleContext(BaseModelicaParser.NamedArgumentsContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_functionPartialApplication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionPartialApplication" ):
                listener.enterFunctionPartialApplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionPartialApplication" ):
                listener.exitFunctionPartialApplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionPartialApplication" ):
                return visitor.visitFunctionPartialApplication(self)
            else:
                return visitor.visitChildren(self)




    def functionPartialApplication(self):

        localctx = BaseModelicaParser.FunctionPartialApplicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_functionPartialApplication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 998
            self.match(BaseModelicaParser.T__10)
            self.state = 999
            self.typeSpecifier()
            self.state = 1000
            self.match(BaseModelicaParser.T__13)
            self.state = 1002
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==74:
                self.state = 1001
                self.namedArguments()


            self.state = 1004
            self.match(BaseModelicaParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputExpressionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_outputExpressionList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputExpressionList" ):
                listener.enterOutputExpressionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputExpressionList" ):
                listener.exitOutputExpressionList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputExpressionList" ):
                return visitor.visitOutputExpressionList(self)
            else:
                return visitor.visitChildren(self)




    def outputExpressionList(self):

        localctx = BaseModelicaParser.OutputExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_outputExpressionList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1007
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 540713447445381392) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 5719) != 0):
                self.state = 1006
                self.expression()


            self.state = 1015
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 1009
                self.match(BaseModelicaParser.T__17)
                self.state = 1011
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 540713447445381392) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 5719) != 0):
                    self.state = 1010
                    self.expression()


                self.state = 1017
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_expressionList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionList" ):
                listener.enterExpressionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionList" ):
                listener.exitExpressionList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionList" ):
                return visitor.visitExpressionList(self)
            else:
                return visitor.visitChildren(self)




    def expressionList(self):

        localctx = BaseModelicaParser.ExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_expressionList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1018
            self.expression()
            self.state = 1023
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 1019
                self.match(BaseModelicaParser.T__17)
                self.state = 1020
                self.expression()
                self.state = 1025
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArraySubscriptsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subscript(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BaseModelicaParser.SubscriptContext)
            else:
                return self.getTypedRuleContext(BaseModelicaParser.SubscriptContext,i)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_arraySubscripts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArraySubscripts" ):
                listener.enterArraySubscripts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArraySubscripts" ):
                listener.exitArraySubscripts(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArraySubscripts" ):
                return visitor.visitArraySubscripts(self)
            else:
                return visitor.visitChildren(self)




    def arraySubscripts(self):

        localctx = BaseModelicaParser.ArraySubscriptsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_arraySubscripts)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1026
            self.match(BaseModelicaParser.T__66)
            self.state = 1027
            self.subscript()
            self.state = 1032
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 1028
                self.match(BaseModelicaParser.T__17)
                self.state = 1029
                self.subscript()
                self.state = 1034
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1035
            self.match(BaseModelicaParser.T__67)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubscriptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BaseModelicaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_subscript

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubscript" ):
                listener.enterSubscript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubscript" ):
                listener.exitSubscript(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubscript" ):
                return visitor.visitSubscript(self)
            else:
                return visitor.visitChildren(self)




    def subscript(self):

        localctx = BaseModelicaParser.SubscriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_subscript)
        try:
            self.state = 1039
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1037
                self.match(BaseModelicaParser.T__14)
                pass
            elif token in [4, 8, 14, 17, 22, 34, 48, 55, 56, 57, 58, 65, 66, 67, 69, 71, 74, 75, 77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1038
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.StringCommentContext,0)


        def annotationComment(self):
            return self.getTypedRuleContext(BaseModelicaParser.AnnotationCommentContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComment" ):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)




    def comment(self):

        localctx = BaseModelicaParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_comment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1041
            self.stringComment()
            self.state = 1043
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==72:
                self.state = 1042
                self.annotationComment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringCommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(BaseModelicaParser.STRING)
            else:
                return self.getToken(BaseModelicaParser.STRING, i)

        def getRuleIndex(self):
            return BaseModelicaParser.RULE_stringComment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringComment" ):
                listener.enterStringComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringComment" ):
                listener.exitStringComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringComment" ):
                return visitor.visitStringComment(self)
            else:
                return visitor.visitChildren(self)




    def stringComment(self):

        localctx = BaseModelicaParser.StringCommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_stringComment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1053
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 1045
                self.match(BaseModelicaParser.STRING)
                self.state = 1050
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==55:
                    self.state = 1046
                    self.match(BaseModelicaParser.T__54)
                    self.state = 1047
                    self.match(BaseModelicaParser.STRING)
                    self.state = 1052
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationCommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classModification(self):
            return self.getTypedRuleContext(BaseModelicaParser.ClassModificationContext,0)


        def getRuleIndex(self):
            return BaseModelicaParser.RULE_annotationComment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationComment" ):
                listener.enterAnnotationComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationComment" ):
                listener.exitAnnotationComment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotationComment" ):
                return visitor.visitAnnotationComment(self)
            else:
                return visitor.visitChildren(self)




    def annotationComment(self):

        localctx = BaseModelicaParser.AnnotationCommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_annotationComment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1055
            self.match(BaseModelicaParser.T__71)
            self.state = 1056
            self.classModification()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





